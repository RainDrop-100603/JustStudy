
Django
    
    웹사이트
        /admin : 관리자 화면, config/urls.py 에서 접근주소 변경 가능 
    migration?
        django 는 data models를 확인하고 migration을 생성한다?
            data models - migration - database ? 
            data model을 장고가 사용하는 데이터 유형으로 동기화 하기 위한 migration?
            python manage.py migrate
                데이터를 sql로 migrate
        데이터에 영향을 주는 것이 생기면 migration을 생성하고 migrate 한다.
        migration은 적게 유지하는 것이 좋다. 한개만 있도록 해주자 
    프로젝트 만들기   
    Applications
        models.py : 데이터를 추가할 수 있다
            database label = models.입력형태()
            입력형태는 model field로 검색하면 된다.
            sql database에 data를 빈공간으로 두는 옵션  
                1. default = blabla : deafult value 설정
                2. null = True : 빈 필드 허용
            form 옵션 
                blank = True : 내용을 채우지 않아도 submit 할 수 있다.
                    https://stackoverflow.com/questions/4384098/in-django-models-py-whats-the-difference-between-default-null-and-blank
            model field 
                image: Pillow 설치 필요 -> bubble화되어있다면 pipenv 사용하자
                char: max_length 필수, 선택지 제한 기능(choices = choice_tuple)
                    choice_tuple = ( (database name 1, form name 1), (2,2), ...)
                text : 일반적인 text field 
                Date : 날짜, sql기본값이 없기때문에 null=True가 불가능하다.
                DateTime : 더 세부적인 날짜
                    두 Date 모두 객체 업데이트시간(auto_now), 생성시간(auto_now_add)를 이용할 수 있다.
        admin.py: admin 설정 관리
            admin.py에서 사용자가 만든 model을 이용하려면,admin class에 register 해야한다.
                여러개의 model을 한 admin에 동시에 register 할 수 있다.
            아래 내용은 사용자가 만든 User model을, 사용자가 만든 CustomUserAdmin에 register한 것이다.
                이때 CustomUserAdmin은 UserAdmin을 상속하여 확장시킨 것이다.  
                    @admin.register(models.User, models.anotherClass1)
                    class CustomUserAdmin(UserAdmin)
                        blablabla
            상속 선택지
                admin.ModelAdmin : 기본값이 없는 상속?
                UserAdmin : Django가 제공하는 기본 admin    
                    from django.contrib.auth.admin import UserAdmin
                    UserAdmin.fleldsets : 기본 admin의 default fieldsets
                    fieldsets = UserAdmin.fieldsets + CustomAdmin 과 같이 혼용 가능 
            요소
                list display: 정렬 항목에서 보일 것 선택
                list filter: 항목 필터에 사용할 것 선택 
                fieldsets: 정보를 그룹지어 나타낸다
                    ( (field 1 name, {"classes":("bla",), "fields":(model1,model2)}), (field 2 name ~) ... )
                    classes: 해당 fieldset의 특성을 바꾼다.
                        collapse: fieldset을 열고 닫게 해준다.
                ordering : 정렬의 기준이 되는 element 선정(나이, 성별 순 등)
                search_field: 대상 search
                    검색옵션: startswith(^), iexact(=), search(@), icontains(None)
                filter_horizontal: ManyToMany에서 작동, 좌측은 미선택, 우측은 선택 박스
                function : row에 ele 대신 function을 넣을 수 있다.
                    ManyToMany등의 요소는 row에 넣을 수 없기때문에, func를 이용하면 유용하다.
                        def name(self, obj): return "strings"
                        self = this admin, obj = model that use this admin 
                ele.short_description: admin panel에서의 항목설명을 바꿀 수 있다.
        
    CustomCommand 만들기
        
        THIRD_PARTY_APPS
            django-seed: fake-data 생성기, install django-seed 필요 
                구조
                    from django_seed import Seed: Seed import
                    seeder=Seed.seeder(): seed함수     
                    seeder.add_entity(User,num,{options}): User obj를 option에따라 num개 생성
                    created=seeder.execute(): 생성한것을 적용, 생성한것들의 pk queryset? 반환
                        pk를 통해 obj를 불러올 수 있으므로, 일단 생성한 후 elements를 수정해도 된다.
                            room=room_models.Room.objects.get(pk=pk)
                    cleaned=flatten(created.values())
                        created는 깔끔한 list가 아니므로 values만 추출하여 list로 만들었다.
                        cleaned=flatten(list(created.values())): list없어도 동작하는데?   
                options
                    {ele1:bla, ele2:blabla, option3, ...} 와 같은 형식 
                    option으로 정해지지 않은것은 랜덤으로 설정된다.
                    완전랜덤이 아닌 logic을 원한다면, lambda x: 를 이용하면 된다,
                    ForeignKey, ManyToMany와 같이 다른 model의 class를 지정하는것은 랜덤생성이 불가하다.
                        직접 logic을 설계해야한다.
                        all_users = user_models.User.objects.all() 와 같은 방식으로 target model class를 가져와야한다.
                            위 방법은 object가 많을 경우 비효율적이므로 권장되지 않는다. 참고만 하자 
                가짜데이터 생성
                    https://faker.readthedocs.io/en/master/
                    from faker import Faker     
                        Faker().text(), and etc ...
                    django-seed 에서 faker를 포함하므로, seed를 통해 사용해도 된다.
                        seed.Seeder.faker.func()
                    lambda x: seeder.faker.text()로 사용 해야 진정한 랜덤 
                        lambda가 있어야 매번 fake-data를 생성한다.
                    ManyToMany
                        일단 생성 후 pk를 이용하여 다시 불러와서 원소를 넣는다.
                            Room.amenities.add(a)
                        random을 이용하여 확률적으로 넣어도 된다.
                            if random.randint(3,17) % 7 == 5  
                    OneToOne
                        미리 target을 지정하여 Book.objects.create() 형식으로 생성하자
                        중복 pk(id) 필터링은 필수 
                    ForeignKey
                        lambda x: random.choices(list) 등을 이용하여 랜덤을으로 지정하자.

        기타 요소
            import random
                fake data logic을 설계에 유용하게 사용할 수 있다.
            from django.contrib.admin.utils import flatten
                정확히 무슨 기능과 용도인지 추가바람 
                seeder.execute()가 iterator을 반환하는가?
                    https://www.programiz.com/python-programming/methods/built-in/filter
                ret={<class "movies.models.Movie">: [1,2,3,4,5, .. ,num]} 의 형식으로 반환되고
                ret.values() = ([[1,2,3,4,5, .. ,num]]) 과 같이 반환된다.
                flatten(ret.values()) = [1,2,3,4,5, .. ,num]
            from datetime import datetime, timedelta
                timedelta(days=random.randint(3, 25)): 시간을 추가하는 용도로 쓰인다.
    기타요소
        class Meta: 추가적인 기능, 정보등을 다루는 class
            abstract: 자체 database를 사용하지 않는 model임을 나타낸다.
                즉 대부분, 상속을 위한 class가 이 속성을 가진다.
                abstractUser도 abstract의 성질을 가진다.
            verbose_name: admin panel에서 표기되는 이름
            verbose_name_plural: admin panel에서 표기되는 복수형 이름 
        relationship
            다른 app의 model에서 생성된 obj와 연결한다.
            obj의 변수 또한 접근이 가능하다. self의 변수와 동일하게 이용 가능한듯?
                str 방식: "host__superhost"
            종류
                ForeignKey(many to one)
                ManyToMany
                OneToOne
            args 
                blank = True : all
                    주로 ManyToMany에서 많이 이용한다.
                on_delete: ForeignKey, OneToOne?
                    연결 대상(상위객체)이 삭제될 때의 self(하위객체)의 동작
                        CASCADE: 상위객체가 삭제되면 하위객체도 삭제
                        PROTECT: 상위객체를 삭제하려면 하위객체가 없어야함
                        etc... on document    
                related_name: all
                    상위객체에서 하위객체들을 찾을 때, set의 형태로 찾을 수 있다.
                    이 set의 이름을 바꾸어 주는 역할을 한다.
                    set_eleName에서 set_related_name으로 바뀐다. 
                limit_choices_to  
                    선택할 수 있는 상위객체를 제한
                    조건: AND OR
                        AND: limit_choices_to={'share_holder': True, 'distributor': True}
                        OR : Q(share_holder=True) | Q(distributor=True)
                    What is Q 
                        bool 조건에 더 다양한 선택지를 주는 것 같다.
                        https://stackoverflow.com/questions/30181079/django-limit-choices-to-for-multiple-fields-with-or-condition
                        https://docs.djangoproject.com/en/dev/topics/db/queries/#complex-lookups-with-q
        get model from string 
            Django의 특징 
            class가 현재 class보다 아래에서 정의되었거나, 다른 model에 존재하는 경우 유용하다.
            model class를 modelName.className 대신, "modelName.className"으로 불러오는 방법
                다른 model에서 import하는 것이 아니면, modelName은 제외한다
                import model1 as model1111 일 경우, "model1111.className"도 되는지 확인요망
            https://stackoverflow.com/questions/4881607/django-get-model-from-string
            https://docs.djangoproject.com/en/2.2/ref/applications/#initialization-process
            https://docs.djangoproject.com/en/3.2/ref/applications/#django.apps.AppConfig.get_model




decorator
    class 바로 위에 적어서, decrator의 내용을 아래 class에 적용한다.
        @admin.register(models.User)
        class CustomUser(UserAdmin):
            blabla
    decorator를 쓰지 않는다면, 아래와 같이 하면된다
        class CustomUser(inherit):
            blabla
        ... other codes ... (중간이 비어도 된다는 뜻)
        admin.site.register(models.User, CustomUser)

SQL Database    
    여러 종류가 있다. 
        dq.splite3 
    첫 행은 변수이름 = 변수형식 으로 지정한다. 다음행부터는 데이터 입력


장고는 database랑 통신
장고 ORM (object relational mapping): 파이썬 코드를 sql문으로 바꿔서 데이터베이스가 알아먹도록 
	model에 넣는것을 database로 변경
    Django가 sql언어로 알아서 바꾸어준다.

Chrome localhost 접속불가 
    https://solbel.tistory.com/586
    크롬은 http localhost를 강제로 https localhost로 바꾼다.
    https설정이 안되어 있다면 접속할 수 없다. 

정보 관리
    사용자가 직접 내용을 입력
        model을 admin에 등록 - admin panel에서 수정 가능
    사용자는 정해진 항목을 선택
        등록 x - 코딩을 통해서만 항목을 수정 가능 
        ex: 국가목록의 경우에는 직접 추가하기보다는, 이미 있는 것들만 사용하게 하도록

 