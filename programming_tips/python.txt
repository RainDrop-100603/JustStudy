=====목차=====
약속 
기타 
	라이브러리 
pip와 pipenv
	pip install [패키지] : --user 옵션
	가상화의 필요성
	pipenv
Linter & Formatter
	Linter
	Formatter
정리 필요 
	pickle
==============


-----약속----- 
변수는 한국어로 [날짜] 와 같은 형식으로 기록하였다.


-----기타-----
	라이브러리: https://docs.python.org/3/library/
	numpy
	matplotlib
      
-----pip와 pipenv ----- 
pip install [패키지] : --user 옵션 
	pip는 [패키지]를 system경로에 설치한다.
		[패키지]를 이용할 때마다 root권한을 얻거나, 
		system directory를 일반 사용자에게도 허락해야한다.
	--user 옵션을 이용하여 root권한 없이 사용자 directory에 설치 가능하다.
		사용자 directory 주소 : /home/[유저이름]/.local/bin 
		$ python3 -c 'import site; print(site.USER_BASE)' 을 통해 주소를 얻을 수 있다.
	사용자 directory는 PATH지정이 안되어 있으므로, PATH지정을 해야한다. 
		~/.profile 편집 vs ~/.bashrc 편집 
			.profile은 Login Shell을 위한것이고, .bashrc는 Non Login Shell을 위한것이다.
			Login Shell은 ID/PW를 입력하는 상황, Non..은 GUI에서 터미널을 여는 상황이다.
			Non.. 은 Login Shell에서 상속받는다.
			따라서 .profile에 PATH를 추가하는 것이 권장된다.
		~/.profile 편집 
			if [ -d "$HOME/.local/bin" ] ; then
				PATH="$PATH:$HOME/.local/bin"
			fi
		~/.bashrc 편집
			export PATH="$HOME/.local/bin:$PATH"
	참고 링크 
		https://www.lesstif.com/python/python-pip-user-mode-95879683.html
가상화의 필요성
	pip는 모든 프로그램을 전역으로 설치한다.
		각 프로젝트의 도구(django등)를 격리하여 다룰 수 없다.
	pipenv, venv는 가상화를 지원한다. 
pipenv
	bubble - 가상화 이용법
		pipenv --three : python3를 이용하는 bubble 생성
		pipenv shell : bubble 진입, bubble 생성/진입을 제외한 작업들은 진입 후 해야한다.
			exit: bubble에서 나간다.
		pipenv install [패키지] : [패키지]를 bubble에서만 이용하도록 설치한다. 
		exit : bubble에서 나온다. 
	.gitignore 
		Pipfile과 Pipfile.lock은 가상화 관련 파일이므로, 업로드하지 않도록 하자 
		*Pipfile.lock은 django를 설치해야 생기는것으로 보아, 프로그램이 설치해야 생기는 듯 하다.
	vscode 
		vsc는 좌하단에서 interpreter을 선택 가능하다. 
    	따라서 pipenv shell을 이용하지 않더라도, interpreter을 사용하면 알아서 가상환경을 세팅한다.
        	which python, which python3를 해보면 확인 가능하다.
		문제는, 잘못된 폴더의 가상환경을 선택한다면 모듈화가 꼬일 수 있다.
		따라서 interpreter는 python을 공통적으로 사용하고, pipenv를 통해 가상화에 진입하자 
		settings.json: 현재 파일에서 터미널이 열리게 해준다.
			"terminal.integrated.cwd": "${fileDirname}"
	주의 사항 
		폴더 경로를 바꾸면, 가상화도 새로 만들어진다. 
			해결방법 추가바람 
		가상화 제거는 그냥 폴더를 삭제하면 된다.
			//wsl$/Ubuntu/home/rain/.local/share/virtualenvs/[폴더]


-----Linter & Formatter-----
Linter
	python은 compiled 언어가 아니기 때문에, compile 전에 에러를 파악할 수 없다.
	linter는 예상되는 에러를 찾아내준다.
	python PEP 라는 python 작성 약속에 위배되는 코드도 알려준다.
	flake8 등이 있다.
Formatter
	python PEP 에 따라 코드를 보기좋게 수정해준다. 
	black 등이 있다.


-----정리 필요-----

csv module
  데이터를 쓸 때마다 줄바꿈이 생긴다면, 파일을 open할 때 newline을 ""나 "\n"으로설정하자
    ""과 "\n"이 무슨 차이인지는 잘 모르겠다.
    f=open(filename,mode="w",newline="")

문자열이 길어질경우 아래와 같이 나눌 수 있다.
  "150문자열"="75문자열""75문자열"            

pipenv 구현원리 추가바람 

Python  
    from . import func : .은 현재 폴더를 의미한다.
        즉, 같은 폴더내의 있는 파일들의 func를 import 한다는 뜻의 코드
    class definition: 정의 바로 아래 """class definition"""을 추가한다.
        class name에 커서를 올리면 class definition이 보인다
    __init__.py : 좀 애매한데 추후 다시 공부하자 
        폴더에 이것을 넣어두면, 파이썬이 이 폴더를 import한 것과 같은 역할이다.
        따라서 폴더랑 같은 위치에 있는 다른 파일에서, 폴더내의 파일을 사용할 수 있다.
        ex) : manage.py의 os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
    __str__ : 추후 공부 더 필요
        파이썬과 장고의 모든 class가 가지고 있는 method
        obj를 발견했을때, 그것을 표현하는 방법이다.
            기본적으로는 __str__은 obj의 이름을 반환한다.
            __str__을 수정함으로서, 다양한 str을 반환할 수 있다.
            obj.ele, "strings", f"{obj.ele} is ele" 등등, str형식이면 다 된다.
    상속
        여러개를 상속할 수 있다? django만 가능? 

sudo apt-get update && sudo apt-get upgrage : 무언가를 설치하기 전에 반드시 하자
    sudo apt upgrade python3 : 선택사항
    sudo apt install python3-pip : pip설치

-----numpy 
	목표: 수학적 연산기능을 구현한다. 
	numpy배열 
		연산: 배열의 크기가 동일하거나, 배열과 스칼라의 연산 (브로드캐스트)
			각 연산은 같은 위치에 있는 원소들의 연산, 즉 행렬끼리 곱한다고 행렬곱이 되지는 않음 
			행렬곱은 np.dot(a,b)로 구현한다. 
		브로드캐스트: 배열과 스칼라의 곱셈을 가능하게 해주거나, 형상이 유사한 배열(2x3대 2x1)의 곱셈을 가능하게 해준다. 
		함수
			np.array(): 배열 생성
			np.arange(a,b,c): a<= x < b 범위에서 c 간격으로 원소 배열 생성 
			np.sin(arrX): 행렬의 원소에 sin값을 취한다. 
			arrX.shape: 행렬의 크기(모양)
			arrX.dtype: 행렬의 원소의 자료형 
			arrX.flatten: 다차원 배열을 차원 배열로 변환 
			arrX[idx]: idx의 원소를 가져옴
			arrX[np.array([idx1,idx2,idx3])]: idx1, idx2, idx3의 원소를 모두 가져와서 행렬로 반환 
			arrX[arrX>=15]: 행렬에서 원소의 크기가 15이상인 것들만 가져온다.
				해석: arrX>=15를 하면 array([True,True,False,...],dtype=bool)과 같은 행렬을 반환한다. 
						arrX>=15의 결과대로 원소를 가져와 행렬로 반환하므로, 결과적으로 arrX>=15인 조건을 만족하는 행렬을 반환하는 형태 
	
	y[np.arange(batch_size), t]
	해석: 
		1. numpy arr은 python의 기본 arr과는 다른 특징이 존재한다. 여기서 사용할 특징은 아래와 같다.
			numpyArr[0,1] = numpyArr[0][1]
			즉 다차원배열을 접근할 때, 콤마를 이용하여 접근하는 방법이 존재한다는 것이다. 
		2. numpy에는 배열연산을 지원하여 간편한 배열 연산을 가능하게 해준다. 아래를 확인해보자  
			a = [0,1], b=[3,7] 
			numpyArr[a,b] = [numpyArr[0,3], numpyArr[1,7]] (python배열은 에러를 내뿜게 된다.)
			즉, python에서는 하지 못하는 연산이 numpy에서는 가능함을 알 수 있다.
			numpyArr이 다차원 배열이라면, numpyArr[a,b,c,d, ...] 도 가능할 것이다. 
			유의사항: 배열 a와 배열 b의 크기는 같아야 한다. 
		결론: 위 1번과 2번을 조합해보면, 위 식의 결과는 아래와 같다.(참고로 t또한 배열이며 크기는 batch_size 만큼이다.)
			ret = [y[0,t0], y[1,t1], y[2,t2], ...]

-----matplotlib
	목표: 그래프를 그려 데이터를 시각화한다. 
		plt 
			함수 추가바람?
		matplotlib.image
			함수 추가바람? 

		추가해야하나? document를 보는게 더 빠르지 않나? 

-----pickle
	특정 객체를 파일로 저장할 수 있는 기능 
		로컬스토리지와 같이 이용할 수 있다. 서버에서 파일을 불러올 때 최초 한번만 불러오고 이후에는 pickle를 이용하는 식으로 



    