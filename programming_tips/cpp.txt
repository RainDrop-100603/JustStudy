c++ tips

상수는 int로 취급된다. long long으로 취급하고 싶다면, LL 혹은 i64 를 상수뒤에 붙이면 된다.
참조형 변수를 여러개 선언할 때, int &var1, &var2 와 같이 선언해야한다.

https://seastar105.tistory.com/65
explicit 생성자에 대한 내용 

long long 과 int는 수행시간에 차이가 난다. long long이 필요한 것이 아니라면 int를 사용하자 
	int, long long, double, float 연산 수행시간 추가바람 

register int 라는것이 있다.

lambda function 
	기본 구성
		[introducer caputre](parameters) ->returnType {statement}
		introducer capture: lambda에서 외부 변수를 사용하고 싶을 때 이용한다.
			&: 모든 외부 변수를 reference로 가져온다. 
			=: 모든 외부 변수를 value로 가져온다.
			&, x: 모든 외부변수를 reference로 가져오되, x만 value로 가져온다.
			=, &x, &y: 모든 외부변수를 value로 가져오되, x y 만 reference로 가져온다.
		parameters: 함수내부에서 이용할 parameters를 나타낸다. 
			원본함수(lambda를 이용하는 함수)의 parameters와 같다고 보면된다.
			없을경우 생략 가능하다. 
		->returnType: return이 존재할경우 이용한다. 없다면 생략 가능
		statement: logic을 구성하는 부분
	참고
		https://modoocode.com/196

++var과 var++의 차이를 잘 구분해야 한다. iterator을 쓸 때 어쩔 수 없이 쓰곤 한다. 
	var2 = ++var -> var을 증가시키고 할당한다. var2 == var
	var2 = var++ -> var을 할당하고 증가시킨다. var2 == var - 1

c++의 동적할당은 new와 delete를 이용한다.
	new 선언은 pointer를 반환한다. 
	tree를 어떻게 구현할 것인가? 
		1. node와 tree를 분리해서 구현한다. node를 직접적으로 다루지 않으며, 기본적으로 tree를 다룬다. 
			장점: node를 사용자가 직접 다루지 않으므로, new와 delete를 자유롭게 이용 가능하다. 
			단점: subtree에 접근하여 무엇을 하는것이 다소 어렵다. 그런데 우리가 subtree에 직접 접근 할 이유가 있을까? 
				구현이 다소 중복되는 느낌? 사실 node자체로 tree 구현이 가능하다. 
				재귀를 구현하기 어렵다. 
			구현: node와 tree를 일치시키는 것과 크게 차이가 나지는 않는다. 오히려 new와 delete가 자유롭다는 장점이 있다. 
		2. node자체가 tree의 역할을 한다. node를 직접적으로 다룬다. "1"과 반대라고 생각하면 된다. 
		3. node자체가 tree의 역할을 하도록 한다. 하지만 node를 다루는것은 tree를 통해서만 다루도록 한다. 
			즉 tree는 node를 할당(new,delete)하는 역할만 하며, 기본적인 기능은 node에서 구현하는 것이다. 
			장점: node 자체가 tree의 역할을 하는것의 단점은, new 와 delete를 직접 할당해야 한다는 것이다. 
					이를 tree를 통해 자동으로 함으로써, 이용자는 할당에 대해 신경 쓸 필요가 없다. 