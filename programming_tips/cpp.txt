c++ tips

상수는 int로 취급된다. long long으로 취급하고 싶다면, LL 혹은 i64 를 상수뒤에 붙이면 된다.
참조형 변수를 여러개 선언할 때, int &var1, &var2 와 같이 선언해야한다.

https://seastar105.tistory.com/65
explicit 생성자에 대한 내용 

long long 과 int는 수행시간에 차이가 난다. long long이 필요한 것이 아니라면 int를 사용하자 
	int, long long, double, float 연산 수행시간 추가바람 

register int 라는것이 있다.

lambda function 
	기본 구성
		[introducer caputre](parameters) ->returnType {statement}
		introducer capture: lambda에서 외부 변수를 사용하고 싶을 때 이용한다.
			&: 모든 외부 변수를 reference로 가져온다. 
			=: 모든 외부 변수를 value로 가져온다.
			&, x: 모든 외부변수를 reference로 가져오되, x만 value로 가져온다.
			=, &x, &y: 모든 외부변수를 value로 가져오되, x y 만 reference로 가져온다.
		parameters: 함수내부에서 이용할 parameters를 나타낸다. 
			원본함수(lambda를 이용하는 함수)의 parameters와 같다고 보면된다.
			없을경우 생략 가능하다. 
		->returnType: return이 존재할경우 이용한다. 없다면 생략 가능
		statement: logic을 구성하는 부분
	참고
		https://modoocode.com/196

++var과 var++의 차이를 잘 구분해야 한다. iterator을 쓸 때 어쩔 수 없이 쓰곤 한다. 
	var2 = ++var -> var을 증가시키고 할당한다. var2 == var
	var2 = var++ -> var을 할당하고 증가시킨다. var2 == var - 1

c++의 동적할당은 new와 delete를 이용한다.
	new 선언은 pointer를 반환한다. 

new와 delete를 이용해야하는 class 구현 
	tree 
		node를 만들고 지우는데 new와 delete를 이용해야 한다. 
		node는 기본적인 기능만 구현하고, new와 delete는 이용하지 않는다.
		tree에서 node를 이용할 때, new와 delete를 구현한다. 
			insert(new), erase(delete), tree erase(모든 node delete)

tree 구현 
	추천: node는 기초적인 기능만, tree가 node를 다루도록 구현한다. 
		new와 delete를 이용하는것에 자유롭다. 
		node의 기능이 단순하기 때문에, tree만 신경쓰면 된다.
		root가 비어있는 경우도 구현이 가능하다. 
	실패1: node에 모든 기능을 구현한다.
		this포인터를 활용하면 다소 비직관적이며, NULL node를 다루기 어렵다.
		root가 비어있는 경우를 구현하기 까다롭다. 
	실패2: node에 모든 기능을 구현하고, tree는 가볍게 node를 다룬다. 
		node와 tree를 모두 신경써야해서, 비 직관적이며 구현에 실수가 생길 가능성이 크다.
		