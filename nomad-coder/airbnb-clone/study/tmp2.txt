---1차정리 - 2차정리 - 동영상보며 최종정리---



-----기타-----
동영상 보며 정리할 단원들이 많다. 
ch10까지는 대부분 기능적인 base를 설명하기 위함이고, 실제로 사용하는 방식은 추후 변경될 수 있다.
    예를들면 sql이나 이미지 업로드 
Django queryset은 Lazy하다.
    all=ele.objects.all()를 정의해도, 실제로 사용하기 전까지는 불러오지 않는다.
    따라서 all[:10]은 all에서 10개를 추려내는것이 아니라, 10개만 불러오는 것이다.
div0 에러를 조심하자
THIRD_PARTY_APPS를 등록 안하느 이유:    
    장고에서 사용하는 것이 아니고, 각 앱에서 독립적으로 import되어 사용되기 때문이다.
    등록되는 앱들은 다 django framework에서 사용하는 것들이다.
seeder.execute()로 생성된것은 queryset인가?
    cleaned에서 list()를 추가해야 하는가? 
django에서는 ()을 생략해도 함수라고 쳐 주는가? 
파이썬 super()
    parent class 의 내용을 사용하고 싶을 때 
https://tutorial.djangogirls.org/ko/ 참고, 장고 듀토리얼 
커서 컨트롤 
    "Insert cursor at end of each line selected"
        shift alt i 
        선택한 line들의 끝에 커서를 놔준다. 
    ctrl i : 커서를 모두 왼쪽 끝으로 이동 
-----ch10-----
url response
    urls
        urlpatterns = [path1(url, view), path2(), path3(), ...]
            url의 HttpRequest에 따른 view실행, view에서는 HttpResponse를 보낸다.
        다루는 법
            1. config - urls.py에서 모든 urlpattenrs를 직접 만든다.
            2. 각 applications에 urls.py를 만들고, config - urls.py에서 이를 불러온다.
        urls.py를 각각 다루는 법
            1. cofing - urls에서 app- urls를 include 한다.
                from django.urls import path, include
                urlpatterns=[
                    path("",include("core.urls",namespace="core")),
                    path("movies/",include("movies.urls",namespace="movies")),
                    path("admin/",admin.site.urls),
                ]
            2. 각 applications에 urls.py를 만든다.
                from django.urls import path 
                app_name = "ThisIsNamespace"
                urlpatterns=[
                    path("", views.func1, name = "bla1"),
                    path("p1/", views.func2, name = "bla2"),
                ]
            최종 주소
                config - urls 의 주소에 app - urls의 주소가 합쳐진 형태
                "/movies/", "/movies/p1/"
        namespace and name
            .html에서, 링크를 탈 때, 주소를 하드코딩 하지 않아도 namespace:name을 통해 이동하게 해준다.
            namespace가 있으므로 name이 겹쳐도 된다는 장점이 있다.
            주소가 바뀌더라도 namespace:name이 그대로라면, .html을 수정하지 않아도 된다.
            config - urls에서 namespace도 include하는 것이 필수인지는 모르겠다. 그냥 하자
        기타 팁: 
    view
        HttpRequest가 들어오면 실행되는 함수
        HttpResponse
            HttpRequest에 대한 응답
            하드코딩을 원하면 직접 import하여 사용해도 된다.
                from django.http import HttpResponse
            django에서는 일반적으로 render을 이용한다.
        def viewFunc(request):
            bla~
            return render(request,"bla.html",context={"arg1":var1,"arg2":var2})
        render
            HttpResponse를 포함한 .html을 만들어준다.
            bla.html을 반환한다.
                HttpResponse도 포함? 아직 크게 이해는 안됨 추가바람 
            bla.html에 context={args}를 전달하여 변수로 이용하게 해준다.
        request
            Django는 HttpRequest를 python object로 변환시켜, 첫번째 인자로 준다.
            var(request)를 통해 인자의 내용을 확인 가능하다.
            ?name=var1와 같이, 추가적인 입력또한 모두 여기 있다.
                request.GET.get("name")으로 추출 가능하다.
    template
        django에서 .html 파일들은 templates 폴더에 저장된다.
        경로 설정
            settings.py의 TEMPLATES의 DIRS=[] : templates 폴더의 경로
            일반적으로 가장 상단에 배치된다.
                os.path.join(BASE_DIR,"templates")
                    BASE_DIR의 경로에 "templates" 경로를 합친 듯
        html 
            변수는 {{var}}, 함수는 {% func %} 형식을 통해 이용할 수 있다.
                함수 내부에서는 변수를 그냥 사용해도 된다.
                들여쓰기는 필요없다.
            VSC에서 django를 설치하면 자동완성이 된다.
            구조 팁
                base.html
                partials - folder : base.html의 element를 분리해놓는다.
                app1 - folder : app1의 html들을 저장한다.
                app2 - folder 
        상속과 포함
            상속과 포함을 통해, 요소들을 분리하여 구현할 수 있다.
            base.html 과 partials - folder를 통해 outline을 생성한다.
            extends : 상속
                parent
                    {% block contentsName %} {% endblock %}
                child 
                    {% extends "base.html" %} : 상속 표시
                    {% block contentsName %} contents {% endblock contentsName%}
                        : contentsName에 맞춰 contents를 넣는다.
            include : 포함
                {% include "partials/nav.html" %}
                    : import와 유사하다. 다른 html에 있는 요소를 넣는다.
        함수    
            if : else : endif
            for ~ in : endfor
        아이콘
            &copy

ClassBasedView 
    설명 
        from django.views.generic import bla 
        편하게 볼 수 있는 Doc: https://ccbv.co.uk/
        django에서 미리 구현되어 있는 classView, 상속하여 이용한다. 
            변수를 지정하면 알아서 자료들을 만들어 html에 넘긴다. 
            함수 오버라이딩을 통해, 일부 동작들을 바꿀 수 있다. 
        urlpatterns에서, class.as_view()를 입력해주어야한다. 
            class는 view로서 사용할 수 없기 때문에, 내장된 변환 기능을 사용한다. 
        vs Function Based View 
            FBV는 data를 직접 가공한다. 사용자가 원하는대로 구현 가능하다. 
            CBV는 data가공을 django class가 대신 해준다. 부분적으로 수정 가능하다. 
            어떤것을 쓰든, HTML은 직접 구현해야 한다. 
    종류 
        ListView: model을 page로 나누어 보여주는 CBV
    변수&함수 설명
        model 
            model = models.Room : 다룰 model Class를 지정해준다. 
                html에서 object_list라는 이름으로 들어간다. 
            context_object_name = "Room" : HTML에서의 obj이름을 변경한다. 
            ordering = "created_by" : ordering 
            HTML 
                ListView: object_list 
        context
            def get_context_data(self,**kwargs):    //HTML에 보낼 context 수정 
                context=super().get_context_data(**kwargs)  //default context를 불러온다.
                context["now"] = timezone.now() //context의 내용을 수정한다 . 
                return context 
        pagination : ListView 
            paginate_by = 10: 한 page에 들어갈 obj의 갯수를 지정한다.
            paginate_orphans = 3: 마지막 obj가 10+3개 이하면, 한 page에 모두 표현한다.
            HTML 
                page_obj : 현재 page를 다루는 obj 
                page_obj.paginator : 전체 page를 다루는 obj  
        기타 
            template_name : html 경로를 지정해준다. default = appname/classname_CBV.html
                ListView : appname/classname_list.html 
            template_name_suffix : _CBV 부분을 변경해준다. 

QuerySet.order_by 
    ascending: .order_by("ele")
    descending: .order_by("-ele")

HTML 변수 & 함수 
    <a href="{% url "core:homepage" kwarg1 kwarg2 %}"> </a> : namespace:name을 통해 url설정 가능 

URL dispatcher
    kwarg 추가
        urls.py : /<int:year>/ , 형식:이름 으로 받아올 수 있다.
        views.py : FBV에서는 함수를 선언할 때 추가해주어야 하고, CBV에서는 self.kwargs에 저장된다.
        html : {% url "core:homepage" kwarg1 kwarg2 %} , kwarg를 같이 보내야한다. 
        reverse : reverse("namespace:name", kwargs={kwarg1,kwarg2,}), kwarg를 추가한다. 
    models.py 
        get_absolute_url : 
-----ch?-----  
make Fake Data
