chg2 
https://replit.com/@RainDrop97/2ndAssignmentBoilerplate#users/admin.py
https://replit.com/@RainDrop97/DelightfulEvilCamel#.replit

chg3 
https://replit.com/@RainDrop97/3rdAssignmentBoilerplate#.replit
https://replit.com/@RainDrop97/LoathsomeLazyAbility#.replit

타임스탬프 모델을 만들기 위해서 추상 클래스(Abstract base classes)를 이용했습니다. 추상 클래스는 DB 테이블을 만들지 않는 기본 모델 클래스입니다. created_at, updated_at 필드를 가진 추상 클래스(Abstract base classes) Core Model을 만들어서 각각의 모델들이 상속받았습니다. 구체적으로 만드는 방법을 알아보면 python manage.py startapp core커맨드를 이용해서 core 앱을 만들어 줍니다. config 앱의 settings.py 에서 core앱을 등록시킵니다. core 앱의 models.py 에서 추상 클래스인 Core Model을 만들어 줍니다. 내부 클래스인 class Meta에 abstract=True을 설정하면 Core Model은 추상 클래스가 됩니다.
Core Model에서 볼 수 있는 DateField에서 auto_now_add 필드 옵션은 객체가 처음 생성될 때 자동으로 현재 시각이 필드 값이 되도록 합니다. auto_add 필드 옵션은 객체가 저장될 때마다 자동으로 현재 시각이 필드 값이 되도록 합니다. 두 필드 옵션을 이용해서 created_at, updated_at 필드를 만들었습니다.
메타 클래스(class Meta)에서 옵션으로 기본 정렬을 결정하는 ordering, 테이블의 이름을 결정하는 db_table, 사용자를 위한 이름을 결정하는 verbose_name이 있습니다. 더 자세한 옵션들은 메타 클래스 공식 문서를 통해서 확인 할 수 있습니다.
IntegerField는 정수를 저장할 때 사용하는 필드입니다. FloatField는 소수 부분이 있는 float값을 저장하는 필드입니다. ImageField는 이미지 파일을 저장하는 필드입니다. ImageField는 pillow 라이브러리가 필요합니다.
모델들 간에 관계가 다대일인 경우에는 ForeignKey필드를 사용하고 다대다일 때 ManyToManyField필드를 사용합니다. 일대일인 경우 OneToOneField 필드를 사용합니다.
다대일 관계를 나타내는 ForeignKey는 인자로 모델 이름이 필요하고 다음으로 on_delete에 대한 옵션이 필요합니다. on_delete은 ForeignKey필드가 바라보는 객체가 삭제될 때 본 객체를 어떻게 할 것인지 결정합니다. on_delete=models.SET_NULL인 경우 ForeignKey필드가 바라보는 객체가 삭제될 때 본 객체에 null값을 할당합니다. null=True일 경우에만 가능합니다. on_delete=models.CASCADE인 경우 ForeignKey필드가 바라보는 객체가 삭제될 때 본 객체 또한 삭제합니다. OneToOneField에서도 on_delete옵션이 같게 적용됩니다.
ForeignKey필드에 related_name 옵션은 ForeignKey필드가 바라보는 객체에서 본 객체를 역으로 참조할 때 사용하는 이름을 설정합니다. 예를 들어 Book Model에서 category = models.ForeignKey(...생략, related_name="books")필드를 참고해보면 category = Category.objects.get(id = 1)에서 해당 카테고리가 포함하는 모든 책을 알고 싶다면 category.books.all()을 사용해서 알 수 있습니다. ManyToManyField에서 related_name옵션도 같은 역할을 합니다.
다대다 관계면 사용하는 ManyToManyField는 ForeignKey필드와 같이 인자로 모델 이름이 필요합니다. related_name 옵션으로 역참조로 사용할 문자열을 설정합니다. 예를 들면 FavList Model에서 books = models.ManyToManyField("books.Book", related_name="fav_lists")으로 정의했습니다. 일대일 관계를 나타내는 OneToOneField는 ForeignKey필드와 같이 인자로 모델 이름이 필요하고 on_delete 옵션이 있습니다. 예를 들면 FavList Model에서 created_by = models.OneToOneField("users.User", on_delete=models.CASCADE)으로 정의했습니다. 애플리케이션에서 사용자 1명당 하나의 FavList를 만들어 주기 위해서 OneToOneField를 사용했습니다.
저번 챌린지와 마찬가지로 admin.register 데코레이터는 모델 클래스들을 어드민 패널에 등록시키기 위해 Model Admin 클래스를 감싸줍니다. 예를 들면 **@admin** .register(Book) 데코레이터를 사용해서 Book Model이 어드민 패널에 보일 수 있도록 합니다.
저번 챌린지와 마찬가지로 list_display를 이용해서 리스트 페이지에서 보이는 필드를 결정합니다. list_filter를 이용해서 사이드 바에서 보일 필터를 결정합니다.

chg4
https://replit.com/@RainDrop97/LoathsomeLazyAbility-1
https://replit.com/@RainDrop97/JoyfulInsidiousAutomaticvectorization

https://velog.io/@kmnkit/Django-Seed-Faker%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%B4%9D%EC%A0%95%EB%A6%AC
https://github.com/Brobin/django-seed/blob/master/django_seed/seeder.py

명령어를 만들기 위해서 management/commands폴더를 각각의 앱에 만들어야 합니다. 그리고 commands폴더 안에 seed_x.py파일을 만들어줍니다. seed_x.py파일 안에는 django.core.management.base.BaseCommand를 상속하는 Command클래스를 만들어줘야 합니다.
BaseCommand.help 속성은 명령어에 대한 도움말을 설정합니다. 솔루션 파일에서 명령어 python manage.py seed_books --help를 실행시키면 "This command seeds books"라는 도움말을 볼 수 있습니다. Command클래스의 help속성(Attribute)값이 출력됐습니다.
handle(self, *args, **options)메서드는 명령어의 로직을 처리하는 부분입니다. BaseCommand 클래스의 서브클래스들은 handle 메서드를 반드시 구현해줘야 하고 구현하지 않으면 NotImplementedError가 발생합니다.
add_arguments(self, parser)메서드를 통해서 인자를 추가합니다. parser는 CommandParser객체입니다. CommandParser클래스는 ArgumentParser클래스를 장고에 맞게 변경한 것입니다. ArgumentParser에 대한 자세한 내용은 argparse 공식문서에서 확인할 수 있습니다.
books 앱을 보면 parser.add_argument("--total", help="How many books do you want to create?", default=10)를 통해 --total인자를 추가합니다. help는 python manage.py seed_books --help명령어를 실행시켰을 때 출력되는 도움말입니다. default는 --total인자가 생략시 기본값입니다. handle(self, *args, **options)에서 options['total']로 참조할 수 있습니다.
django_seed는 테스트 DB 만드는 것을 도와줍니다. 테스트 DB를 만들기 위해서 Seed 모듈을 가져오고(import) seeder객체를 생성합니다. 그리고 seeder.add_entity() 메서드를 사용하면 됩니다. seed_books.py를 보면 from django_seed import Seed로 Seed 모듈을 가져옵니다. seeder = Seed.seeder()로 seeder 객체를 생성한 뒤 seeder.add_entity(Book, total, {"year": lambda x: seeder.faker.year(), ... 생략 ... })로 테스트 DB를 생성합니다. add_entity()메서드에 첫 번째 인자는 모델 클래스가 오고 두 번째 인자는 DB의 개수입니다. 세 번째 인자로 직접 만들 필드에 대한 함수를 가진 dict가 옵니다. seeder.execute()를 실행하면 DB에 테스트 케이스들 생성합니다.
handle(self, *args, **options)메서드에서 self.stdout.write()함수를 사용해서 콘솔에 문자열을 출력할 수 있습니다.
seeder = Seed.seeder()는 locale값으로 지역 설정을 할 수 있습니다. locale값의 기본값은 'en_US'입니다. faker 공식문서에서 가능한 locale값들을 찾을 수 있습니다. 참고로 한국 값은 'ko_KR'입니다. Seed.seeder(locale='ko_KR')로 한국에 맞는 값들을 얻을 수 있습니다. 솔루션에서 사용한 seeder.faker.year(), seeder.faker.name(), seeder.faker.sentence()는 'en_US'문서에서 어떤 값을 반환하는지 알 수 있습니다.
Person.objects.filter(kind=Person.KIND_WRITER)은 kind=Person.KIND_WRITER 조건을 만족하는 Person의 QuerySet을 반환합니다. Category.objects.get_or_create(name=genre, kind=Category.KIND_BOOK)은 name=genre, kind=Category.KIND_BOOK 조건을 만족하는 Category DB가 존재하면 존재하는 것을 반환하고 존재하지 않으면 새로 생성하는 메서드입니다. QuerySet 공식문서를 보면 자세한 사항을 확인할 수 있습니다.

chg5
https://replit.com/@RainDrop97/JoyfulInsidiousAutomaticvectorization-1