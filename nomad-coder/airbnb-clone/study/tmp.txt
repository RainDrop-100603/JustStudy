study tmp 


Admin panel
    ordering
    many to many lise_display 방법
        amenities 대신 count_amenities list
        def django_count_amenities(self,obj):
            """self: admin class, obj = 현재 row """
            return "potato"
        count_amenities.short_description = "hello sexy!"
            list의 label, 즉 count_amenities 대신 hello sexy가 row의 label이 된다.
        함수는 클릭해서 정렬 불가
        obj.amenities.all()
        obj.amenities.count()


   
python: __str__ 과 __repr__의 차이 
    https://shoark7.github.io/programming/python/difference-between-__repr__-vs-__str__
python: __ini__ 찾아보기 

_set : 나를 (ForeignKey등으로) 지정한 객체들의 리스트 
    a Foreignkey to B -> B has a_set
    related_name: a_set의 이름을 바꿔준다
        related_name이 같아도 된다? 


Relationship
    QuerySet: ManyToMany, Foreignkey
        ManyToMany, Foreignkey (from) 등으로 지정된 target에는, set_fromName 이라는 QuerySet이 생성된다.
            related_name="names"를 ManyToMany, Foreignkey의 arg로 넣으면, set_fromName이 names로 이름이 바뀐다.
            related_name은 같은 target에 대해서는 모두 이름이 달라야 한다. (당연히 중복되면 안된다.)
                from이 같더라도 target이 다르면 이름이 동일해도 상관없다. 이것은 target에 생성되는 것이지, from에 생성되는 것이 아니기 때문이다.
    요소 
        obj.name.count(): ManyToMany
            개수를 세준다.
        obj.name.all(): ManyToMany
            모든 요소를 queryset으로 반환한다.


django에서 python으로 database 다루기
    순서
        pipenv shell
        python manage.py shell
        from usr.models import User : 다루기 원하는 요소 import
    함수
        exit(): console 종료 
        objects: python을 통해 database에서 정보를 가져올 수 있게끔 한다? 아니면 object(객체)를 다루는 요소, 즉 전체 컨트롤 API의 일부? 
            className.objects.all(): 모든 obj를 QuerySet형식으로 반환한다.
            className.objects.count(): obj의 개수를 반환한다. 
        vars(class): return __dic__ of class
        dirs(class): return list of names in the current local scope(==class)
    QuerySet
        QuerySet.filter(조건): 조건에 따른 QuerySet 반환, startswith과 같은 검색조건도 설정 가능하다.
            ex: User.filter(name__startswith = "sweet") 
        Get(조건): 조건에 맞는 obj를 반환한다.
            조건: id=1 or pk(primary key)=1 (idx start from 1), name = "sweet House", etc ...
            여러개를 찾을경우 ModelClassName.MultipleObjectsReturned 예외 발생 
            하나도 없을경우 ModelClassName.DoesNotExist 예외 발생 
    참고
        Making Queries Documeny를 보면, data model을 만들면 자동으로 database-abstraction API를 생성해준다. (이것이 objects 함수?)
        파이썬과 같이 변수지정을 할 수 있다. ex: userQuery=User.objects.all()
        Ctrl + L = clear console 
        database가 변경되면, console을 재시작 해야한다? migration이 변경되면인가 database가 변경되면인가?

class가 아닌 특정 조건을 가진 obj 에 대한 code 도 작성이 가능하다? 

여러 model Object가 동일한 기능을 구현해야 한다면, 해당 object를 하나의 admin Class 에 register시키는 것도 좋은 방법이다.
    ex: used_by(self,obj): ret obj.rooms.count() -- 특정 facility가 존재하는 room 갯수, 특정 amenity가 존재하는 room 갯수는 동일한 함수를 통해 구현된다. 


/////////////////////////////////////////////////////////////////////ch8
UserAdmin.list_filter 

어떤 기능이 admin panel 뿐 아니라 모든곳(admin,frontend,console ...)에 있기를 원한다 -> admin.py 가 아닌 model.py에서 정의하면 된다.

list_display에 __str__도 넣을 수 있다 

방의 전체 평점을 구하는 방법
    def total_rating(self):
        all_reviews = self.reviews.all() // 방이 가진 모든 reivew의 QuerySet 반환 
        avg = 0
        for review in all_reviews:
            avg += review.rating_average()
        return avg/len(all_reviews)

django.utils timezone
    django에서 제공하므로 기능호환성이 좋다 
    함수    
        timezone.now().date() : 현재시각 

funcName.boolean = True : admin panel에서 boolean 형식으로 보여준다. 

python ", ".join(arr) : list의 요소를 모두 이은 str 반환, ""안에 있는 것은 list요소 사이사이에 추가한다. 
    즉 여기선 "ele1, ele2, ele3, ele4" 와 같은 str이 반환된다.

-------------------------------------ch9

Photo random import
미리 파일들을 model폴더에 넣어둔다(ch8참고)

9.7의 6분 8초 보면, 배열을 한번에 다 추가할수도 있는듯?

9단원 정리 하고  세모
Challenge하고    O
8단원하고 정리하고  X
Code 정리하기   X

----ch 11 & 12----
function based view
    def function을 통해 기능 구현
    간단해지긴 했지만 여전히 많은 반복작업 필요 (비슷한 기능 매번 구현)
class based view
    django가 미리 만들어둔 기능을 class를 통해 상속하여 이용한다.
        from django.views.generic import bla~
        urlpatterns - path는 함수만 view로서 갖는다.
            따라서 class에서 함수를 가져와야 한다.
            .as_view()를 통해 class에서 정의한 것들을 함수로 바꾸어 반환한다.
            .as_view()는 이미 내장되어 있다.
        각 parent마다 정해진 html이 있다.
            ListView의 경우는 room_list.html 
        각 기능들은 doc를 봐도 되고, 아래사이트에서 봐도 된다.
            https://ccbv.co.uk/
    기능
        ListView
            변수지정
                model = models.Room : 다루기 원하는 class model
                    model을 정의하면 알아서 원하는 양식들을 만들어 낸다.
                    html: object_list라는 이름으로 들어감, 이름변경 가능   
                ordering: model ordering
                paginate_by: 한 페이지에 표현하는 갯수 
            page_obj : paginator가 이미 정의되어 있다.
    context 수정 방법
        class내부에 아래 내용을 정의하면 된다.
        def get_context_data(self,**kwargs)
            context=super().get_context_data(**kwargs)  //context불러오기
            context["now"] = timezone.now() //context에 원하는 내용 추가 
            return context
    기타
        function based view에서는 data를 직접 가공해야 했다.
        class based view는 data의 가공을 대신 해준다. 
        html에서 직접 구현해야 하는것은 동일하다. 
    
function based view:
    def funcName(request)
    html에 보낼 데이터를 직접 가공한다.
class based view:
    class className(parent) 
    parent class를 상속하여 이용한다. 
    몇몇 변수를 지정해주면 ,데이터 가공은 class에서 알아서 해준다.

차이점: 데이터 가공을 직접하는가, class가 알아서 해주는가
공통점: 가공된 데이터로 html을 구성하는것은 직접 해야한다.

queryset .order_by
    ascending: .order_by("ele")
    descending: .order_by("-ele")

<a href="{% url "core:homepage" %}">
<a href="{{ url('admin:index') }}">

url dispatcher
    변수 받아오기
        urls.py에서 /<int:year>/ 같은 형식으로 지정하면 된다.
        views.py에서 arg도 추가해야한다. 
            function based view: def room_detail(request,year)
            class based view: pk같은 경우는 알아서 받아온다. 다른 변수도 어디 저장할듯?
        .html
            hard coding: 그냥 해주면 됨
            func : {% url "namespace:name" year %} 과 같은 형식
    models
        def get_aboulute_url(self)
            absolute url은 website/ 부터 시작하는 url을 말하는 듯 하다.
            근데 이거 어디다 써먹어?
    reverse 
        .html에서는 {% url "namespace:name" args %}을 통해 이동한다.
        django에서는 reverse("namespace:name", kwargs={args})를 통해 이동한다.
    models.Model.DoesNotExist  
        pk에 해당하는 obj가 없을경우 해당 에러 반환.
    없는 주소 에러 처리
        function based view
            try except를 이용한 redirect
            try except를 이용한 Http404 에러 raise 
                from django.http import Http404
        Class based view 
            알아서 처리해줌 
        html
            templates - 404.html을 통해 꾸밀 수 있다.
                DEBUG=False, ALLOWED_HOST 설정 필요(ALLOWED_HOST="*" 해도 되네? 12.3)

class based view
    DetailView
    objcet이름 바꾸면, html에서 object라는 것을 여전히 사용할 수 있을까?
    pk도이름을 바꿔줄 수 있다 -> pk 대신 potato를 찾아 pk처럼 쓰게 할 수도 있다.
    일부 arg들은 자동으로 찾아준다.

base.html에는 되도록 변수자체보다는, block을 이용하자 
    변수 자체를 쓰면, context에 매번 변수를 넣어야 한다.

endblock 뒤에 contentsName은 선택사항? 

search 
    function based view 
        <form method="get" action = "anyway, url" ></form>: 입력들을 컨트롤, 모든것은 form 내부에        
            <label for="city">City</label>: label
            <input name="city"> : 검색창, name은 주소창에 드는 arg
            선택창: 사용자에게 보이는것은 country.name, 가져가는 arg는 country.code 
                <select name = "country"> 
                    {% for country in countries %}
                    <option value="{{country.code}}">{{country.name}}</option>
                    {% endfor %} 
                </select>  
                selected특성을 이용하여, 현재 페이지의 내용과 내가 고른것의 내용이 같은지 확인할 수 있다.
                    ex) <option {% if country.code == s_country %}selected{% endif %}>
                        country.code는 현재 선택된 것, s_country는 이 page의 countrycode 
            <button> submit </button> : form에 button이 하나뿐이면, 자동으로 submit역할을 한다.
            name = value로 가져간다.(주소창, 선택창 참고)
        app마다 각각 검색창이 필요하므로, base.html에 넣어둬야 한다.(not header.html)
        view에 변수가 너무 많을때
            특성에 따라 각각의 dict로 나눈다(form, choices, ...)
            context = {**form, **choices}와 같이 하면 합쳐진다.


--ch 23--

UpdateView
    class django.views.generic.edit.UpdateView
    객체를 수정하는 view, Class Based View 
        validation error을 잡아주며, object를 수정하는 것을 도와준다.
    요소
        model : object의 model 지정
        template_name : edit page의 template 지정
        fields : edit 할 element 지정 
    submit 하면 get_aboulute_url로 복귀(반환)
    보안문제
        주인이 아니어도, url을 입력하면 edit page등에 접근 가능 
    default로 pk를 받는다 (굳이 안외워도 에러메시지로 파악 가능하긴 하다.)

Edit page
    CBV, mixin_LoggedInOnly & UpdateView 상속 
    def get_objcet: 주어진 pk로 obj를 가져오는 method, 없다면 404error raise 
        오버라이드 : room.host.pk와 self.request.user.pk가 같은지 확인하여 다르면 404error raise하자 

photo edit page 기능구현 
    view: DetailView, mixin_LoggedInOnly
        html에서 img src = "{{ phtoto.file.url }} "을 통해 이미지 표현 
    delete: FBV, Login_required Decorator(@)
        room_pk와 photo_pk를 모두 받아야 한다. 
        Login_required는 settings.py에 LOGIN_URL필요 (역시 에러메시지로 확인 가능)
            해당 url로 redirect? 
        QuerySet에서 원소 선택하여 delete 
            models.Photo.objects.filter(pk=photo_pk).delete()
            아마 get같은것으로 원소 선택해도 될것같긴 하다. 
        지운 후 view로 redirect
        room.host.pk와 user.pk 체크 
    edit: UpdateView, mixin_LoggedInOnly
        get_success_url을 override하여 view로 redirect 
    upload photo: FormView, mixin_LoggedInOnly
        CreateView vs FormView 
            CreateView로는 room_pk를 설정할 수 없어서, FormView를 이용한다. 
        var 설정 
            model = models.Photo 
            template_name = "bla"
            fields = ("caption", "file")
                정해진 방에 photo를 업로드 하는 것이므로, 유저가 관여하는 field는 위 두개 
            form_class = forms.CreatePhotoFrom
                수행할 form을 지정한다. 
        method override 
            form_valid(self, form)
                form이 valid하면 실행한다. 
                HttpResponse를 ret한다. 
                form.save(pk)를 통해, 정해진 방(pk=pk)에 photo Object를 저장한다. 
        form.py: 살펴보기 
            class CreatePhotoFrom(forms.ModelForm):
                class Meta: 
                    model = model.photo 
                    fields = ("caption", "file")
                def save(self,pk,*args,**kwargs):
                    photo = super().save(commit=False)
                    bla 
                    photo.save()
            해석 
                .save(commit = False) : 생성하자마자 저장하지 않고, 추가 데이터를 수정할 수 있다.
                    photo.save()를 통해 저장 
                class Meta: save()를 할 때, 지정되는 것들을 적어놓은듯? 
    기타기능 
        SuccessMessageMixin
        messages.success(request, "bla") 적절히 활용 (delete success! 등 )

Sessions (view)
    database가 필요없는 정보를 다룰때 쓴다.
        host mode vs user mode 
        database에 저장할 필요가 없다. 
    사용법 
        session start : session 추가 
            request.session["is_host"] = True
        session stop : 2가지 방법
            1. del request.session["is_host"] : try ~ except KeyError 이용
            2. request.session.pop["is_host]  : 예외설정 필요없나? 
        switch_host : session start, stop을 동시에 구현 
            try (session stop 1) except KeyError (session start)
    html 
        request.session 에 저장된다.

Creating Room page 
    upload photo와 같이 form 필요 (user와 연결해야하기 때문)
    upload photo와는 다른 방식 이용 
        form 
            def save(self, *args, **kwargs): 
                room = super().save(commit=False)
                return room 
        view 
            def form_valid(self, form):
                room = from.save()
                room.host = self.request.user 
                room.save()
                form.save_m2m()
                return redirect(reverse("rooms:detail", kwargs={"pk" : room.pk}))
        해석 
            생성한 obj를 form이 아닌 view에서 저장할 수 있다.
            form에서는 공통된 부분을 만들고, 
                차이가 있는 부분은 각 view에서 설정하도록 할 수도 있을듯 
            room의 pk도 다룰 수 있다. 
            form.save_m2m()
                ManyToMany는 database에 저장된 후 저장할 수 있다.

template - mixin 
    mixin 
        중복되는 code(기능)을 하나의 class로 지정하여 상속하여 이용하는 것이다.
            TimeStampedModel은 변수의 중복을 해결한다면, mixin은 함수의 중복을 해결한다?
            예를 들면, 로그인 한 사람만 접근이 가능하도록 하는 mixin이 있다.
        다중 상속과 비슷하다고 볼 수도 있다.
            다중상속을 지원하지 않는 Ruby등에서 사용하려고 만든 것이다.
            다중상속이 지원되는 언어에서도 mixin이라는 표현을 쓰는것은, mixin의 기능을 강조하기 위해서다
        django에서 여러 mixin을 지원한다.
        custom mixin을 이용하고 싶다면, 각 app에 mixins.py를 만들어 정의한다.
        method 
            test_func : mixin의 참/거짓을 가르는 함수 (로그인 했는가? Y/N)
    template 에서의 mixin? 
        함수엣의 mixin과 같이, 중복 구현을 피하기 위함이다.
            예를들면 input form을 mixin으로 구현하면 간단하다.
            include를 이용한다. 

reverse_lazy
    CBV에서 변수에 주소를 정의할 때 이용한다.
        method를 override할 때는 lazy를 사용하지 않아도 된다.
    FBV에서는 이용할 필요없다. 
    원리
        class-level 속성의 객체는 import될 때 배치되지만, url-solving 규칙은 import시간에 세팅되지 않는다.
        그로인해 URLconf 규칙을 인식하지 못하고, 에러를 발생시킨다. 

kwargs = keyword args 

CreateView & UpdateView
    require pk as kwargs: only UpdateView
        urls.py에서 <int:pk>추가, 혹은 <int:bla>를 추가하고 pk_url_kwarg 수정 
    views.py
        required
            model = Class : 다루기 원하는 class 지정 
            fields = (tuple) : 다루기 원하는 element 지정 
            submit 이후 
               models.py에서 get_aboulute_url을 설정했다면, 해당 url로 redirect 
               혹은 success_url이나 get_success_url을 설정해주면, 해당 url로 redirect
        option 
            template_name : 기본 경로 수정  
            template_name_suffix : 기본경로에서 _의 뒷부분(suffix)만 수정 
            success_url : submit이 일어난 후 redirect할 주소, reverse_lazy 이용 
            def get_success_url: logic이 필요할 경우, success_url대신 여기서 정의, reverse 이용 
                update의 경우, pk를 얻고싶다면 self.kwargs.get("pk")를 통해 얻을 수 있다.
                create의 경우, pk를 얻는 방법을 아직 모른다. FormView이용하자 
        기타 option 
            models.py
                def get_absolute_url(self):
                   return reverse("movies:movie", kwargs={"pk": self.pk})
    template 구성
        기본 경로 : appName/className_form.html 
        CreateView와 UpdateView가 동일한 template로 표현될 수 있다.
            CreateView는 obj를 생성해서 UpdateView를 수행하는것과 다를것이 없기 때문이다.
    html element 
        fields 요소를 자동으로 표시, submit 생성 
            <form method="post">{% csrf_token %}
                {{ form }} // form.as_ul 등 다른 표현이 3개 있다. 
                <input type="submit" value="Update">
            </form>
            https://docs.djangoproject.com/en/3.2/topics/forms/#working-with-form-templates
        csrf토큰에 대해 추가바람 
            https://docs.djangoproject.com/en/3.2/ref/csrf/
        다른 방법은 추가바람 
    기타
        ModelForm 
            https://docs.djangoproject.com/en/3.2/topics/forms/modelforms/#django.forms.ModelForm
        model과 field를 지정하면 알아서 만들어준다. 사용자 지정 form을 이용하고 싶다면 FormView 
DetailView
    require pk as kwargs
        urls.py에서 <int:pk>추가, 혹은 <int:bla>를 추가하고 pk_url_kwarg 수정 
    views.py 
        required
            model = Class 
    template 구성
        기본경로 appName/className_detail.html 
    html element
        className.eleName을 통해 접근 가능 
ListView 
    views.py 
        required 
            model = Class : 다루기 원하는 class 지정 
            paginate_by : pagination 설정, 한 page에 들어가는 ele의 수
        option 
            paginate_orphans : 마지막 page가 orphans개 이하면, 이전 page에 합친다.
            ordering : ele 정렬 기준 
            context_object_name : html에서의 object_list의 명칭을 바꿔준다. 
            def get_context_data(self, **kwargs) : html에 들어가는 context를 수정한다. 
                context = super().get_context_data(**kwargs) : 기본적으로 들어가는 context를 불러온다. 
            template_name : 기본 경로 수정 
    template 구성 
        기본 경로: appName/className_list.html
    html element
        object_list : 현재 page의 element list 
        page_obj : pagination object 
            page_obj.paginator : paginator의 method가 필요하다면 이용 가능 
    기타
FormView 
    추가바람 

각 View들의 공통변수는 한번에 정리해도 될듯

createView 
    /movies/createURL에 GET요청을 하는 경우 템플릿을 반환합니다. POST요청을 하는 경우 영화 객체를 만들어줍니다.
    뭔 뜻? GET 요청과 POST요청? 
updateView 
    GET 요청을 하는 경우 템플릿을 반환하고 PUT이나 POST 요청을 하는 경우 영화 객체를 갱신합니다.