study tmp 


Admin panel
    ordering
    many to many lise_display 방법
        amenities 대신 count_amenities list
        def django_count_amenities(self,obj):
            """self: admin class, obj = 현재 row """
            return "potato"
        count_amenities.short_description = "hello sexy!"
            list의 label, 즉 count_amenities 대신 hello sexy가 row의 label이 된다.
        함수는 클릭해서 정렬 불가
        obj.amenities.all()
        obj.amenities.count()


   
python: __str__ 과 __repr__의 차이 
    https://shoark7.github.io/programming/python/difference-between-__repr__-vs-__str__
python: __ini__ 찾아보기 

_set : 나를 (ForeignKey등으로) 지정한 객체들의 리스트 
    a Foreignkey to B -> B has a_set
    related_name: a_set의 이름을 바꿔준다
        related_name이 같아도 된다? 


Relationship
    QuerySet: ManyToMany, Foreignkey
        ManyToMany, Foreignkey (from) 등으로 지정된 target에는, set_fromName 이라는 QuerySet이 생성된다.
            related_name="names"를 ManyToMany, Foreignkey의 arg로 넣으면, set_fromName이 names로 이름이 바뀐다.
            related_name은 같은 target에 대해서는 모두 이름이 달라야 한다. (당연히 중복되면 안된다.)
                from이 같더라도 target이 다르면 이름이 동일해도 상관없다. 이것은 target에 생성되는 것이지, from에 생성되는 것이 아니기 때문이다.
    요소 
        obj.name.count(): ManyToMany
            개수를 세준다.
        obj.name.all(): ManyToMany
            모든 요소를 queryset으로 반환한다.


django에서 python으로 database 다루기
    순서
        pipenv shell
        python manage.py shell
        from usr.models import User : 다루기 원하는 요소 import
    함수
        exit(): console 종료 
        objects: python을 통해 database에서 정보를 가져올 수 있게끔 한다? 아니면 object(객체)를 다루는 요소, 즉 전체 컨트롤 API의 일부? 
            className.objects.all(): 모든 obj를 QuerySet형식으로 반환한다.
            className.objects.count(): obj의 개수를 반환한다. 
        vars(class): return __dic__ of class
        dirs(class): return list of names in the current local scope(==class)
    QuerySet
        QuerySet.filter(조건): 조건에 따른 QuerySet 반환, startswith과 같은 검색조건도 설정 가능하다.
            ex: User.filter(name__startswith = "sweet") 
        Get(조건): 조건에 맞는 obj를 반환한다.
            조건: id=1 or pk(primary key)=1 (idx start from 1), name = "sweet House", etc ...
            여러개를 찾을경우 ModelClassName.MultipleObjectsReturned 예외 발생 
            하나도 없을경우 ModelClassName.DoesNotExist 예외 발생 
    참고
        Making Queries Documeny를 보면, data model을 만들면 자동으로 database-abstraction API를 생성해준다. (이것이 objects 함수?)
        파이썬과 같이 변수지정을 할 수 있다. ex: userQuery=User.objects.all()
        Ctrl + L = clear console 
        database가 변경되면, console을 재시작 해야한다? migration이 변경되면인가 database가 변경되면인가?

class가 아닌 특정 조건을 가진 obj 에 대한 code 도 작성이 가능하다? 

여러 model Object가 동일한 기능을 구현해야 한다면, 해당 object를 하나의 admin Class 에 register시키는 것도 좋은 방법이다.
    ex: used_by(self,obj): ret obj.rooms.count() -- 특정 facility가 존재하는 room 갯수, 특정 amenity가 존재하는 room 갯수는 동일한 함수를 통해 구현된다. 


/////////////////////////////////////////////////////////////////////ch8
UserAdmin.list_filter 

어떤 기능이 admin panel 뿐 아니라 모든곳(admin,frontend,console ...)에 있기를 원한다 -> admin.py 가 아닌 model.py에서 정의하면 된다.

list_display에 __str__도 넣을 수 있다 

방의 전체 평점을 구하는 방법
    def total_rating(self):
        all_reviews = self.reviews.all() // 방이 가진 모든 reivew의 QuerySet 반환 
        avg = 0
        for review in all_reviews:
            avg += review.rating_average()
        return avg/len(all_reviews)

django.utils timezone
    django에서 제공하므로 기능호환성이 좋다 
    함수    
        timezone.now().date() : 현재시각 

funcName.boolean = True : admin panel에서 boolean 형식으로 보여준다. 

python ", ".join(arr) : list의 요소를 모두 이은 str 반환, ""안에 있는 것은 list요소 사이사이에 추가한다. 
    즉 여기선 "ele1, ele2, ele3, ele4" 와 같은 str이 반환된다.

-------------------------------------ch9

Photo random import
미리 파일들을 model폴더에 넣어둔다(ch8참고)

9.7의 6분 8초 보면, 배열을 한번에 다 추가할수도 있는듯?

9단원 정리 하고  세모
Challenge하고    O
8단원하고 정리하고  X
Code 정리하기   X

----ch 11----
function based view
    def function을 통해 기능 구현
    간단해지긴 했지만 여전히 많은 반복작업 필요 (비슷한 기능 매번 구현)
class based view
    django가 미리 만들어둔 기능을 class를 통해 상속하여 이용한다.
        from django.views.generic import bla~
        urlpatterns - path는 함수만 view로서 갖는다.
            따라서 class에서 함수를 가져와야 한다.
            .as_view()를 통해 class에서 정의한 것들을 함수로 바꾸어 반환한다.
            .as_view()는 이미 내장되어 있다.
        각 parent마다 정해진 html이 있다.
            ListView의 경우는 room_list.html 
        각 기능들은 doc를 봐도 되고, 아래사이트에서 봐도 된다.
            https://ccbv.co.uk/
    기능
        ListView
            변수지정
                model = models.Room : 다루기 원하는 class model
                    model을 정의하면 알아서 원하는 양식들을 만들어 낸다.
                    html: object_list라는 이름으로 들어감, 이름변경 가능   
                ordering: model ordering
                paginate_by: 한 페이지에 표현하는 갯수 
            page_obj : paginator가 이미 정의되어 있다.
    context 수정 방법
        class내부에 아래 내용을 정의하면 된다.
        def get_context_data(self,**kwargs)
            context=super().get_context_data(**kwargs)  //context불러오기
            context["now"] = timezone.now() //context에 원하는 내용 추가 
            return context
    기타
        function based view에서는 data를 직접 가공해야 했다.
        class based view는 data의 가공을 대신 해준다. 
        html에서 직접 구현해야 하는것은 동일하다. 
    
function based view:
    def funcName(request)
    html에 보낼 데이터를 직접 가공한다.
class based view:
    class className(parent) 
    parent class를 상속하여 이용한다. 
    몇몇 변수를 지정해주면 ,데이터 가공은 class에서 알아서 해준다.

차이점: 데이터 가공을 직접하는가, class가 알아서 해주는가
공통점: 가공된 데이터로 html을 구성하는것은 직접 해야한다.

queryset .order_by
    ascending: .order_by("ele")
    descending: .order_by("-ele")

<a href="{% url "core:homepage" %}">
<a href="{{ url('admin:index') }}">

url dispatcher
    변수 받아오기
        urls.py에서 /<int:year>/ 같은 형식으로 지정하면 된다.
        views.py에서 arg도 추가해야한다. 
            function based view: def room_detail(request,year)
            class based view: pk같은 경우는 알아서 받아온다. 다른 변수도 어디 저장할듯?
        .html
            hard coding: 그냥 해주면 됨
            func : {% url "namespace:name" year %} 과 같은 형식
    models
        def get_aboulute_url(self)
            absolute url은 website/ 부터 시작하는 url을 말하는 듯 하다.
            근데 이거 어디다 써먹어?
    reverse 
        .html에서는 {% url "namespace:name" args %}을 통해 이동한다.
        django에서는 reverse("namespace:name", kwargs={args})를 통해 이동한다.
    models.Model.DoesNotExist  
        pk에 해당하는 obj가 없을경우 해당 에러 반환.
    없는 주소 에러 처리
        function based view
            try except를 이용한 redirect
            try except를 이용한 Http404 에러 raise 
                from django.http import Http404
        Class based view 
            알아서 처리해줌 
        html
            templates - 404.html을 통해 꾸밀 수 있다.
                DEBUG=False, ALLOWED_HOST 설정 필요(ALLOWED_HOST="*" 해도 되네? 12.3)

class based view
    DetailView
    objcet이름 바꾸면, html에서 object라는 것을 여전히 사용할 수 있을까?
    pk도이름을 바꿔줄 수 있다 -> pk 대신 potato를 찾아 pk처럼 쓰게 할 수도 있다.
    일부 arg들은 자동으로 찾아준다.