study tmp 


Admin panel
    ordering
    many to many lise_display 방법
        amenities 대신 count_amenities list
        def django_count_amenities(self,obj):
            """self: admin class, obj = 현재 row """
            return "potato"
        count_amenities.short_description = "hello sexy!"
            list의 label, 즉 count_amenities 대신 hello sexy가 row의 label이 된다.
        함수는 클릭해서 정렬 불가
        obj.amenities.all()
        obj.amenities.count()


   
python: __str__ 과 __repr__의 차이 
    https://shoark7.github.io/programming/python/difference-between-__repr__-vs-__str__
python: __ini__ 찾아보기 

_set : 나를 (ForeignKey등으로) 지정한 객체들의 리스트 
    a Foreignkey to B -> B has a_set
    related_name: a_set의 이름을 바꿔준다
        related_name이 같아도 된다? 


Relationship
    QuerySet: ManyToMany, Foreignkey
        ManyToMany, Foreignkey (from) 등으로 지정된 target에는, set_fromName 이라는 QuerySet이 생성된다.
            related_name="names"를 ManyToMany, Foreignkey의 arg로 넣으면, set_fromName이 names로 이름이 바뀐다.
            related_name은 같은 target에 대해서는 모두 이름이 달라야 한다. (당연히 중복되면 안된다.)
                from이 같더라도 target이 다르면 이름이 동일해도 상관없다. 이것은 target에 생성되는 것이지, from에 생성되는 것이 아니기 때문이다.
    요소 
        obj.name.count(): ManyToMany
            개수를 세준다.
        obj.name.all(): ManyToMany
            모든 요소를 queryset으로 반환한다.


django에서 python으로 database 다루기
    순서
        pipenv shell
        python manage.py shell
        from usr.models import User : 다루기 원하는 요소 import
    함수
        exit(): console 종료 
        objects: python을 통해 database에서 정보를 가져올 수 있게끔 한다? 아니면 object(객체)를 다루는 요소, 즉 전체 컨트롤 API의 일부? 
            className.objects.all(): 모든 obj를 QuerySet형식으로 반환한다.
            className.objects.count(): obj의 개수를 반환한다. 
        vars(class): return __dic__ of class
        dirs(class): return list of names in the current local scope(==class)
    QuerySet
        QuerySet.filter(조건): 조건에 따른 QuerySet 반환, startswith과 같은 검색조건도 설정 가능하다.
            ex: User.filter(name__startswith = "sweet") 
        Get(조건): 조건에 맞는 obj를 반환한다.
            조건: id=1 or pk(primary key)=1 (idx start from 1), name = "sweet House", etc ...
            여러개를 찾을경우 ModelClassName.MultipleObjectsReturned 예외 발생 
            하나도 없을경우 ModelClassName.DoesNotExist 예외 발생 
    참고
        Making Queries Documeny를 보면, data model을 만들면 자동으로 database-abstraction API를 생성해준다. (이것이 objects 함수?)
        파이썬과 같이 변수지정을 할 수 있다. ex: userQuery=User.objects.all()
        Ctrl + L = clear console 
        database가 변경되면, console을 재시작 해야한다? migration이 변경되면인가 database가 변경되면인가?

class가 아닌 특정 조건을 가진 obj 에 대한 code 도 작성이 가능하다? 

여러 model Object가 동일한 기능을 구현해야 한다면, 해당 object를 하나의 admin Class 에 register시키는 것도 좋은 방법이다.
    ex: used_by(self,obj): ret obj.rooms.count() -- 특정 facility가 존재하는 room 갯수, 특정 amenity가 존재하는 room 갯수는 동일한 함수를 통해 구현된다. 


/////////////////////////////////////////////////////////////////////ch8
UserAdmin.list_filter 

어떤 기능이 admin panel 뿐 아니라 모든곳(admin,frontend,console ...)에 있기를 원한다 -> admin.py 가 아닌 model.py에서 정의하면 된다.

list_display에 __str__도 넣을 수 있다 

방의 전체 평점을 구하는 방법
    def total_rating(self):
        all_reviews = self.reviews.all() // 방이 가진 모든 reivew의 QuerySet 반환 
        avg = 0
        for review in all_reviews:
            avg += review.rating_average()
        return avg/len(all_reviews)

django.utils timezone
    django에서 제공하므로 기능호환성이 좋다 
    함수    
        timezone.now().date() : 현재시각 

funcName.boolean = True : admin panel에서 boolean 형식으로 보여준다. 

python ", ".join(arr) : list의 요소를 모두 이은 str 반환, ""안에 있는 것은 list요소 사이사이에 추가한다. 
    즉 여기선 "ele1, ele2, ele3, ele4" 와 같은 str이 반환된다.

-------------------------------------ch9

Photo random import
미리 파일들을 model폴더에 넣어둔다(ch8참고)

9.7의 6분 8초 보면, 배열을 한번에 다 추가할수도 있는듯?

9단원 정리 하고  세모
Challenge하고    O
8단원하고 정리하고  X
Code 정리하기   X

----ch 11 & 12----
function based view
    def function을 통해 기능 구현
    간단해지긴 했지만 여전히 많은 반복작업 필요 (비슷한 기능 매번 구현)
class based view
    django가 미리 만들어둔 기능을 class를 통해 상속하여 이용한다.
        from django.views.generic import bla~
        urlpatterns - path는 함수만 view로서 갖는다.
            따라서 class에서 함수를 가져와야 한다.
            .as_view()를 통해 class에서 정의한 것들을 함수로 바꾸어 반환한다.
            .as_view()는 이미 내장되어 있다.
        각 parent마다 정해진 html이 있다.
            ListView의 경우는 room_list.html 
        각 기능들은 doc를 봐도 되고, 아래사이트에서 봐도 된다.
            https://ccbv.co.uk/
    기능
        ListView
            변수지정
                model = models.Room : 다루기 원하는 class model
                    model을 정의하면 알아서 원하는 양식들을 만들어 낸다.
                    html: object_list라는 이름으로 들어감, 이름변경 가능   
                ordering: model ordering
                paginate_by: 한 페이지에 표현하는 갯수 
            page_obj : paginator가 이미 정의되어 있다.
    context 수정 방법
        class내부에 아래 내용을 정의하면 된다.
        def get_context_data(self,**kwargs)
            context=super().get_context_data(**kwargs)  //context불러오기
            context["now"] = timezone.now() //context에 원하는 내용 추가 
            return context
    기타
        function based view에서는 data를 직접 가공해야 했다.
        class based view는 data의 가공을 대신 해준다. 
        html에서 직접 구현해야 하는것은 동일하다. 
    
function based view:
    def funcName(request)
    html에 보낼 데이터를 직접 가공한다.
class based view:
    class className(parent) 
    parent class를 상속하여 이용한다. 
    몇몇 변수를 지정해주면 ,데이터 가공은 class에서 알아서 해준다.

차이점: 데이터 가공을 직접하는가, class가 알아서 해주는가
공통점: 가공된 데이터로 html을 구성하는것은 직접 해야한다.

queryset .order_by
    ascending: .order_by("ele")
    descending: .order_by("-ele")

<a href="{% url "core:homepage" %}">

url dispatcher
    변수 받아오기
        urls.py에서 /<int:year>/ 같은 형식으로 지정하면 된다.
        views.py에서 arg도 추가해야한다. 
            function based view: def room_detail(request,year)
            class based view: pk같은 경우는 알아서 받아온다. 다른 변수도 어디 저장할듯?
        .html
            hard coding: 그냥 해주면 됨
            func : {% url "namespace:name" year %} 과 같은 형식
    models
        def get_aboulute_url(self)
            absolute url은 website/ 부터 시작하는 url을 말하는 듯 하다.
            근데 이거 어디다 써먹어?
    reverse 
        .html에서는 {% url "namespace:name" args %}을 통해 이동한다.
        django에서는 reverse("namespace:name", kwargs={args})를 통해 이동한다.
    models.Model.DoesNotExist  
        pk에 해당하는 obj가 없을경우 해당 에러 반환.
    없는 주소 에러 처리
        function based view
            try except를 이용한 redirect
            try except를 이용한 Http404 에러 raise 
                from django.http import Http404
        Class based view 
            알아서 처리해줌 
        html
            templates - 404.html을 통해 꾸밀 수 있다.
                DEBUG=False, ALLOWED_HOST 설정 필요(ALLOWED_HOST="*" 해도 되네? 12.3)

class based view
    DetailView
    objcet이름 바꾸면, html에서 object라는 것을 여전히 사용할 수 있을까?
    pk도이름을 바꿔줄 수 있다 -> pk 대신 potato를 찾아 pk처럼 쓰게 할 수도 있다.
    일부 arg들은 자동으로 찾아준다.

base.html에는 되도록 변수자체보다는, block을 이용하자 
    변수 자체를 쓰면, context에 매번 변수를 넣어야 한다.

endblock 뒤에 contentsName은 선택사항? 

search 
    function based view 
        <form method="get" action = "anyway, url" ></form>: 입력들을 컨트롤, 모든것은 form 내부에        
            <label for="city">City</label>: label
            <input name="city"> : 검색창, name은 주소창에 드는 arg
            선택창: 사용자에게 보이는것은 country.name, 가져가는 arg는 country.code 
                <select name = "country"> 
                    {% for country in countries %}
                    <option value="{{country.code}}">{{country.name}}</option>
                    {% endfor %} 
                </select>  
                selected특성을 이용하여, 현재 페이지의 내용과 내가 고른것의 내용이 같은지 확인할 수 있다.
                    ex) <option {% if country.code == s_country %}selected{% endif %}>
                        country.code는 현재 선택된 것, s_country는 이 page의 countrycode 
            <button> submit </button> : form에 button이 하나뿐이면, 자동으로 submit역할을 한다.
            name = value로 가져간다.(주소창, 선택창 참고)
        app마다 각각 검색창이 필요하므로, base.html에 넣어둬야 한다.(not header.html)
        view에 변수가 너무 많을때
            특성에 따라 각각의 dict로 나눈다(form, choices, ...)
            context = {**form, **choices}와 같이 하면 합쳐진다.


--ch 23--

UpdateView
    class django.views.generic.edit.UpdateView
    객체를 수정하는 view, Class Based View 
        validation error을 잡아주며, object를 수정하는 것을 도와준다.
    요소
        model : object의 model 지정
        template_name : edit page의 template 지정
        fields : edit 할 element 지정 
    submit 하면 get_aboulute_url로 복귀(반환)
    보안문제
        주인이 아니어도, url을 입력하면 edit page등에 접근 가능 
    default로 pk를 받는다 (굳이 안외워도 에러메시지로 파악 가능하긴 하다.)

Edit page
    CBV, mixin_LoggedInOnly & UpdateView 상속 
    def get_objcet: 주어진 pk로 obj를 가져오는 method, 없다면 404error raise 
        오버라이드 : room.host.pk와 self.request.user.pk가 같은지 확인하여 다르면 404error raise하자 

photo edit page 기능구현 
    view: DetailView, mixin_LoggedInOnly
        html에서 img src = "{{ phtoto.file.url }} "을 통해 이미지 표현 
    delete: FBV, Login_required Decorator(@)
        room_pk와 photo_pk를 모두 받아야 한다. 
        Login_required는 settings.py에 LOGIN_URL필요 (역시 에러메시지로 확인 가능)
            해당 url로 redirect? 
        QuerySet에서 원소 선택하여 delete 
            models.Photo.objects.filter(pk=photo_pk).delete()
            아마 get같은것으로 원소 선택해도 될것같긴 하다. 
        지운 후 view로 redirect
        room.host.pk와 user.pk 체크 
    edit: UpdateView, mixin_LoggedInOnly
        get_success_url을 override하여 view로 redirect 
    upload photo: FormView, mixin_LoggedInOnly
        CreateView vs FormView 
            CreateView로는 room_pk를 설정할 수 없어서, FormView를 이용한다. 
        var 설정 
            model = models.Photo 
            template_name = "bla"
            fields = ("caption", "file")
                정해진 방에 photo를 업로드 하는 것이므로, 유저가 관여하는 field는 위 두개 
            form_class = forms.CreatePhotoFrom
                수행할 form을 지정한다. 
        method override 
            form_valid(self, form)
                form이 valid하면 실행한다. 
                HttpResponse를 ret한다. 
                form.save(pk)를 통해, 정해진 방(pk=pk)에 photo Object를 저장한다. 
        form.py: 살펴보기 
            class CreatePhotoFrom(forms.ModelForm):
                class Meta: 
                    model = model.photo 
                    fields = ("caption", "file")
                def save(self,pk,*args,**kwargs):
                    photo = super().save(commit=False)
                    bla 
                    photo.save()
            해석 
                .save(commit = False) : 생성하자마자 저장하지 않고, 추가 데이터를 수정할 수 있다.
                    photo.save()를 통해 저장 
                class Meta: save()를 할 때, 지정되는 것들을 적어놓은듯? 
    기타기능 
        SuccessMessageMixin
        messages.success(request, "bla") 적절히 활용 (delete success! 등 )

Sessions (view)
    database가 필요없는 정보를 다룰때 쓴다.
        host mode vs user mode 
        database에 저장할 필요가 없다. 
    사용법 
        session start : session 추가 
            request.session["is_host"] = True
        session stop : 2가지 방법
            1. del request.session["is_host"] : try ~ except KeyError 이용
            2. request.session.pop["is_host]  : 예외설정 필요없나? 
        switch_host : session start, stop을 동시에 구현 
            try (session stop 1) except KeyError (session start)
    html 
        request.session 에 저장된다.

Creating Room page 
    upload photo와 같이 form 필요 (user와 연결해야하기 때문)
    upload photo와는 다른 방식 이용 
        form 
            def save(self, *args, **kwargs): 
                room = super().save(commit=False)
                return room 
        view 
            def form_valid(self, form):
                room = form.save()
                room.host = self.request.user 
                room.save()
                form.save_m2m()
                return redirect(reverse("rooms:detail", kwargs={"pk" : room.pk}))
        해석 
            생성한 obj를 form이 아닌 view에서 저장할 수 있다.
            form에서는 공통된 부분을 만들고, 
                차이가 있는 부분은 각 view에서 설정하도록 할 수도 있을듯 
            room의 pk도 다룰 수 있다. 
            form.save_m2m()
                ManyToMany는 database에 저장된 후 저장할 수 있다.

template - mixin 
    mixin 
        중복되는 code(기능)을 하나의 class로 지정하여 상속하여 이용하는 것이다.
            TimeStampedModel은 변수의 중복을 해결한다면, mixin은 함수의 중복을 해결한다?
            예를 들면, 로그인 한 사람만 접근이 가능하도록 하는 mixin이 있다.
        다중 상속과 비슷하다고 볼 수도 있다.
            다중상속을 지원하지 않는 Ruby등에서 사용하려고 만든 것이다.
            다중상속이 지원되는 언어에서도 mixin이라는 표현을 쓰는것은, mixin의 기능을 강조하기 위해서다
        django에서 여러 mixin을 지원한다.
        custom mixin을 이용하고 싶다면, 각 app에 mixins.py를 만들어 정의한다.
        method 
            test_func : mixin의 참/거짓을 가르는 함수 (로그인 했는가? Y/N)
    template 에서의 mixin? 
        함수엣의 mixin과 같이, 중복 구현을 피하기 위함이다.
            예를들면 input form을 mixin으로 구현하면 간단하다.
            include를 이용한다. 

reverse_lazy
    CBV에서 변수에 주소를 정의할 때 이용한다.
        method를 override할 때는 lazy를 사용하지 않아도 된다.
    FBV에서는 이용할 필요없다. 
    원리
        class-level 속성의 객체는 import될 때 배치되지만, url-solving 규칙은 import시간에 세팅되지 않는다.
        그로인해 URLconf 규칙을 인식하지 못하고, 에러를 발생시킨다. 

kwargs = keyword args 

CreateView & UpdateView
    require pk as kwargs: only UpdateView
        urls.py에서 <int:pk>추가, 혹은 <int:bla>를 추가하고 pk_url_kwarg 수정 
    views.py
        required
            model = Class : 다루기 원하는 class 지정 
            fields = (tuple) : 다루기 원하는 element 지정 
            submit 이후 
               models.py에서 get_aboulute_url을 설정했다면, 해당 url로 redirect 
               혹은 success_url이나 get_success_url을 설정해주면, 해당 url로 redirect
        option 
            template_name : 기본 경로 수정  
            template_name_suffix : 기본경로에서 _의 뒷부분(suffix)만 수정 
            success_url : submit이 일어난 후 redirect할 주소, reverse_lazy 이용 
            def get_success_url: logic이 필요할 경우, success_url대신 여기서 정의, reverse 이용 
                update의 경우, pk를 얻고싶다면 self.kwargs.get("pk")를 통해 얻을 수 있다.
                create의 경우, pk를 얻는 방법을 아직 모른다. FormView이용하자 
        기타 option 
            models.py
                def get_absolute_url(self):
                   return reverse("movies:movie", kwargs={"pk": self.pk})
    template 구성
        기본 경로 : appName/className_form.html 
        CreateView와 UpdateView가 동일한 template로 표현될 수 있다.
            CreateView는 obj를 생성해서 UpdateView를 수행하는것과 다를것이 없기 때문이다.
    html element 
        fields 요소를 자동으로 표시, submit 생성 
            <form method="post">{% csrf_token %}
                {{ form }} // form.as_ul 등 다른 표현이 3개 있다. 
                <input type="submit" value="Update">
            </form>
            https://docs.djangoproject.com/en/3.2/topics/forms/#working-with-form-templates
        csrf토큰에 대해 추가바람 
            https://docs.djangoproject.com/en/3.2/ref/csrf/
        다른 방법은 추가바람 
    기타
        ModelForm 
            https://docs.djangoproject.com/en/3.2/topics/forms/modelforms/#django.forms.ModelForm
        model과 field를 지정하면 알아서 만들어준다. 사용자 지정 form을 이용하고 싶다면 FormView 
DetailView
    require pk as kwargs
        urls.py에서 <int:pk>추가, 혹은 <int:bla>를 추가하고 pk_url_kwarg 수정 
    views.py 
        required
            model = Class 
    template 구성
        기본경로 appName/className_detail.html 
    html element
        className.eleName을 통해 접근 가능 
ListView 
    views.py 
        required 
            model = Class : 다루기 원하는 class 지정 
            paginate_by : pagination 설정, 한 page에 들어가는 ele의 수
        option 
            paginate_orphans : 마지막 page가 orphans개 이하면, 이전 page에 합친다.
            ordering : ele 정렬 기준 
            context_object_name : html에서의 object_list의 명칭을 바꿔준다. 
            def get_context_data(self, **kwargs) : html에 들어가는 context를 수정한다. 
                context = super().get_context_data(**kwargs) : 기본적으로 들어가는 context를 불러온다. 
            template_name : 기본 경로 수정 
    template 구성 
        기본 경로: appName/className_list.html
    html element
        object_list : 현재 page의 element list 
        page_obj : pagination object 
            page_obj.paginator : paginator의 method가 필요하다면 이용 가능 
    기타
FormView 
    추가바람 

각 View들의 공통변수는 한번에 정리해도 될듯

createView 
    /movies/createURL에 GET요청을 하는 경우 템플릿을 반환합니다. POST요청을 하는 경우 영화 객체를 만들어줍니다.
    뭔 뜻? GET 요청과 POST요청? 
updateView 
    GET 요청을 하는 경우 템플릿을 반환하고 PUT이나 POST 요청을 하는 경우 영화 객체를 갱신합니다.

ch 14~15.3====================

View 
    특징 
        from django.views import View 
        가장 기본적인 View 
    기능 
        required 
            def get(self, request):
            def post(self, request): 

LoginForm 만들기 
    views.py 
        class LoginView(View):
            def get(self, request):
                form = forms.LoginForm(initial={"email": "itn@las.com})
                return render(request, "bla.html",{"form":form})
            def post(self,request):
                form=forms.LoginForm(request.POST)
                return render(request, "bla.html",{"form":form})
        해석
        기타
            form.is_valid()
                forms.py의 clean_bla의 ValidationError와 같은 에러가 발생하면 false 반환 
            form.cleaned_data
                clean_함수들을 수행한 후의 data들 
                clean_함수가 없다면, data원본이 들어가고, 있다면 ret value가 들어간다.
            authenticate, login, logout 
                from django.contrib.auth 
                authenticate(request, username=usr, password=pw)
                    authenticate는 username에 대해서만 확인한다.
                    즉 id가 username이다. email로 로그인을 원한다면, id를 email로 해야하는 것이다.
                    작동 
                        user= authenticate(bla)
                        if user is not None:
                            login(request,user)
                            redirect(reverse(bla))
                    login되면 admin에도 이것이 적용된다. admin권한이 있다면 접근 가능
                    user.is_authenticated: 로그인 되어있는가 확인 
                    def log_out(request):
                        logout(request) //logout은 import된 것이므로 def이름과 겹치지 않도록 주의 
                        return redirect(bla)
                    
            context_processor 
                template에 정보를 자동으로 추가한다
                예를들어 cookie가 있으면, 그걸 가지고 와서 user를 찾고 template에 자동으로 넣어준다.
                따라서 로그인이 되었다면, user는 따로 추가하지 않아도 method가 이용 가능하다. 
    forms.py 
        class LoginForm(forms.Form):
            email = forms.EmailField()
            password = forms.charField(widget=forms.PasswordInput, label="pw")
            def clean_email(self):
                email = sef.cleaned_data.get("email")
                try: 
                    models.User.objects.get(username=email)
                    return email
                except model.User.DoesNotExist:
                    raise forms.ValidationError("User does not exist")
                return (cleaned_data)
            def clean_password(self):
                14.3 source code 참고
        해석 
            특정 field를 지정하여 input을 알아서 확인하고 정리해준다.
            기본적으로 label은 변수이름이지만, 따로 설정해 줄 수도 있다.
            def clean_bla()
                입력값이 이미 존재하는것인지 확인하려면, clean_을 붙여준다.
                단순히 입력값 확인 뿐 아니라, 여러 용도로도 사용할 듯 
                    사용자가 원하는 방식대로 clean한 후 return 하는 것인듯 
                기본적으로 cleaned_data에 모든 입려깅 들어있다(bla뿐아니라 다른것도)
                try except를 통해 입력값이 존재하는지 확인했다. 
            user.check_password(password)
                forms.py의 clean_password에서 이용 
                id_password가 일치하는지 확인 
                if true return pw else raise ValidationError("bla")
            clean_email과 clean_password는 중복되는 부분이 많고, 기능상으로도 상호 연관이 있다.
                clean(self)이용하자 
                clean의 logic 은 clean_bla와 동일하다
                clean의 반환값은 self.cleaned_data이다.
                    username과 password를 모두 반환해야 하므로
                    그렇다면, clean에서는 2개의 변수만 다르고 나머지는 clean_bla에서 다룬다면 어떻게할까? 
            Error 
                clean_pw 에서 error가 발생하면 pw에서 error가 발생한 것으로 간주
                clean 의 경우는 default는 non-field 이다.
                    self.add_error("password", forms.ValidationError("bla"))를 통해 field 설정 가능 
        기타 
            def clean()
                여러 입력에 대한 clean을 수행하고 싶을때 이용
                나중에 다룬다? 
    template 
        form 
            label, input으로 구분됨, 수동으로 만드는건 css part에 나옴 
            form.as_p와 같이 정해진 형식 사용 가능 
                <form method="POST" action="{% url "users:login" %}">
                    {% csrf_token %}
                    {{form.as_p}}
                    <button>Login</button>
                </form>
            method: 
            action: input을 들고갈 link 인듯 
            CSRF: CSRF항목참고, 해킹사이트를 통한 데이터 탈취 방지

Login Easy Way
    LoginView 
    forms.py 
        username과 password를 필요로 한다.
    문서 확인 
    https://docs.djangoproject.com/en/3.2/topics/auth/default/
        LoginView의외에도, auth와 관련된 많은 View 확인 가능 

FormView - LoginView보다는 까다롭지만 customize 용이 
    customize하기에 좋다. 
    Post, Get사용 안함 
    views.py 
        required 
            template_name 
            form_class 
            success_url = reverse_lazy(bla)
                class가 정의될 때 url을 정의하는것이 아니라, url을 사용할 때 정의한다. 
                사용할 때 정의해서 lazy 
            def form_valid(self,form)
                //form이 valid할 경우 실행 
                return super().form_valid(form) //success url로 redirect 
        option 
            initial : 입력값의 초기값 설정 

Signup - FormView 
    views.py 
        clean_email의 try-except는, except일 때 email 반환(중복가입방지 )
    cleaned_data 
        변수가 정의된 순서대로 clean이 실행된다. 
            clean_bla를 정의하지 않으면 default_clean: 값이 그대로 들어간다.
        clean하지 않은 data를 먼저 불러올 순 없다. clean을 해야 data가 존재한다.
        따라서 password가 정의되고 password1이 정의되었다고 가정하면 
            password에서는 cleaned_data.get("password1")을 할 수가 없다. 존재하지 않는다.
            반대로 password1에서는 password를 불러올 수 있다. 
        
create user 
    views.py 
        def form_valid(self,form):
            form.save()
            login logic // 생성하자마자 로그인하고 싶다면 
            return super().form_valid(form)
    forms.py 
        def save(self):
            first_name = self.cleaned_data.get("first_name")
            last_name 
            email
            password 
            user = models.User.objects.create_user(email,email,password)
                // 첫 arg는 username인데, email과 동일하게 할 것이므로 
                // create_user는 우리가 만든거겠지? 
            user.first_name=first_name
            user.last_name 
                // not required는 나중에 추가해줬다.
                // 나중에 추가해야만 하는가, 추가해줘도 되는것인가? 
            user.save()

ModelForm 
    field를 매번 일일히 지정해주지 않아도 되게 해준다. 
    clean method, save method 내장 
    unique field validate 가능 
    사용법 
        forms.py 
            class whatForm(forms.ModelForm):
                class Meta:
                    model = models.User
                    fields = ("first_name","email")
                password = forms.charField()
                def save(self, *args, **kwargs):
                    email=self.cleaned_data.get("email")
                    password=self.cleaned_data.get("password")
                    user=super().save(commit=False);
                    user.username=email
                    user.set_password(password)
                    user.save()

        해석 
            User에 있는 것들을 fields지정함으로서 가져왔다.
            User에 password는 없으므로? 없는것만 추가했다. 
                user는 암호화된 password가 필요해서?
                -> username과 password는 abstractUser에 있는 것이다.
            이때 Meta에 없는것은 blank상태로 설정되므로, default를 정해주는것도 좋다.
                default는 models.py에서 정해준다. 
            save method override 
                원하는대로 설정하기 위함 
                commit = False: obj를 만들고 database에 안올림 
                    obj.save() 해야 database에 올린다. 
                password를 암호화해서 저장 
initialize 
    from_class = forms.LoginForm 는 class를 지정해주는 것이다.__str__을 저장하려나?
    from_class = forms.LoginForm() 는 LoginForm을 initialize 시킨것의 결과를 저장하는 것이다?

CSRF: Cross Site Request Forgery 
    로그인을 할때 website는 나에게 cookies를 준다.
    browser가 backend로 cookies를 보내는 방식은 도메인해 의해 이루어진다.
    로그인을 하고나서 접속할때, 내가 website에 cookies를 줘서 로그인상태임을 알린다. 
    그런데 만약 해킹 website가 facebook에 무언가를 요청하는 link, form button, or javascript를 가지고 있다고 가정하자 
    내가 버튼을 클릭하면, ajax 등을 통해 facebook에 request를 보낸다.
    근데 그 request는 내 browser에서 일어났으므로, browser는 cookies를 보낸다. 
    이때 이 해킹사이트가 cookies를 탈취하여 비밀번호를 바꾼다든지 등 악용을 할 수 있다.
    {% csrf_token%} 
        input type: hidden, name=bla, value=bla 가 생성된다.
        이 것은 token이라고 하는데, 이 token을 가지고 POST request를 해야 한다.
        token을 통해 적절한 웹사이트에서 POST request를 보냈는지 확인할 수 있다.

GET과 POST 
    HttpRequest의 두가지 방식, POST와 GET 방식 
        https://mangkyu.tistory.com/17
    GET 
        주 용도: 정보를 가져와서 조회하기 위함 
        URL에 변수(data)를 포함시켜 요청한다.
            key=value 형태로 전송 
            BODY는 보통 빈 상태로 전송되며, Content-type 헤더필드 추가안함
            HTTP자체는 길이의 제한이 없으나, 브라우저에서 최대길이를 제한한다.
                URL형식에 맞지 않는 파라미터 key나 value는 인코딩해야한다.
        data를 Header에 포함하여 전송한다.
        URL에 data를 노출시키므로 보안에 취약하다.
        캐싱할 수 있다. -> 속도를 높이거나 편리하게 이용 가능 (vsc에서 git사용 생각하자)
        예시: http://localhost:8080/boardList?name=제목&contents=내용
    POST 
        주 용도: 데이터를 서버로 제출하여 추가/수정 하기 위함
        URL에 변수를 노출하지 않고 요청한다.
            BODY에 data를 넣어서 전송
            헤더필드에 Body의 data를 설명하는 Content-type 헤더필드 추가
            길이의 제한은 없으나 Time Out 존재 
        데이터를 Body에 포함시킨다.
        URL에 data가 노출되지 않아 기본적인 보안은 된다.
        캐싱할 수 없다. 
        예시: http://localhost:8080/addBoard 
            addBoard가 Content-type 인듯?



FBV에서의 get과 post 
def login_view(request):
    if request.method == "GET":
        bla 
    elif request.method == "POST"
        bla 

.prittierignore 
    /templates 적어서 template 내부는 prettier 적용 방지 가능 

ModelForm 
    models에서 model Class를 가져온다. 
        model's ele의 model field 에 대응하는 form field 를 가져온다. 
        meta Class 에 정의된 것들만 가져온다. 
        정의 되지 않은 것들은 따로 정의한다
    clean override 
        clean 및 clean_pw등을 모두 override 할 수 있다. 
        save를 override 할 수 있다. 
    save()
        기본적으로 정의되어 있다. 
        model = models.className으로 지정한 것을 저장한다. 
        super().save(commit = False)
            commit = False : database에 바로 저장하지 않고, obj를 ret 한다. 이 obj를 받아 수정하고나서 obj.save()하면 그때 저장된다. 
            filters 에 있는 것들은 자동으로 저장해주며, 없는 것들은 obj.ele = what 으로 추가해야 한다. 
        ModelForm에서는 save를 하려면 view에서 할 수밖에 없다. 


--21.3 ~ 21.7 --
Profile View 

Models
    get_absoulute_url
        def get_absolute_url(self):
            return reverse("users:profile", kwargs={"pk": self.pk}) 
        html에서 url "namespace:name" 대신, model.get_absolute_url 을 이용할 수 있다. 
        Admin Panel의 user detail에, View On Site 버튼이 생긴다. 

Views
    DetailView 
        DetailView의 대상으로 불러온 객체의 이름은 default로 user 임 
            login한 사람을 지정하던 user가, DetailView의 대상으로 바뀌어 버린 것 
            context_object_name = "user_obj" 를 통해, DetailView의 대상의 이름을 바꿔주면 된다. 
    UpdateView 
        Form을 생성하지 않아도 알아서 다 해준다. model, fields 만 지정해주자 
        def get_object(self, queryset=None): 수정하길 원하는 obj를 반환하는 함수
            self.request.user(현재 로그인한 유저)를 반환해버리면 됨, 이러면 pk가 필요없다. 
        작업을 완료하면 get_aboulute_url로 redirect 해줌 
        form_valid 오버라이딩을 통해 추가적인 업데이트 가능하다. 
        Template 
            enctype : text/plain, multipart/form-data, application 인코딩
                multipart/form-data : 파일을 보내면 잘 작동 
            enctype설정을 안하면, backend에서 파일을 받지 못한다. 
    PasswordChagneView 
        template_name을 설정하지 않으면 admin page로 보내버림 

    CBV 
        context_data 확장 
            def get_context_data(self,**kwargs):
                context =super().get_context_data(**kwargs) 
                context["hello"] = "Hello!"
                return context 
            해석 
                context_data를 그냥 불러오면, 현재 객체의 context_data를 불러온다. 
                    즉 데이터를 수정하면 원본데이터를 수정해버리므로 부적절하다. 
                super().get_context_data(**kwargs)
                    kwargs와 super()이용하여, 현재 context_data와 똑같은 context_data를 얻는다. 
                context를 적당히 수정하여 return해주면 된다. 
        Template    
            존재하면 표시하도록 하기 : if user_obj.avatar 이용 
            user 확인 : if user == user_obj
        mixin을 이용한 divide conquer 

Urls 
    주소뒤에는 항상 /을 붙여줘야 한다. 
    include를 하거나, 딸려오는 arg등이 있을때를 대비해서인듯? 
   
super() method에 대한 고찰 
    def form_valid(self,form):
        // some logic 
        return super().form_valid(form)
    위 코드를 살펴보면, logic을 수행한 후에 super().form_valid(form)을 실행한다. 
    이때 form_valid라는 method는 modelForm등의 parentForm에서 상속받은 것이다. 
        즉 super().form_valid(form)은, form_valid method의 원형이라고 볼 수 있다(수정하기 전)
    따라서 위의 method는 원하는 logic을 먼저 수행한 뒤, 원래 정의되어 있던 form_valid를 실행하는 것이라고 볼 수 있다.  
    
template include 
    {% include 'mixins/auth/auth_form.html' with form=form cta="Update Password" %}
        변수도 전달할 수 있다. 

https://docs.python.org/ko/3/library/random.html#module-random

https://faker.readthedocs.io/en/master/

https://github.com/Brobin/django-seed


———ch8
Phto는 url이 필요하다.
Media_root
절대경로가 필요하다
Print(BASE_DIR)로 구할 수 있다
Media 폴더를 만들어서 다룰 수 있다
Media_Root = os.path.join(BASE_DIR, “uploads”)
Media root를 지정하고 업로드하면, 정해진 root에 사진이 업로드된다. Uploads폴더 이름은 아마 수정해도 될듯?
ImageField의 upload_to에 경로를 지정하면, uploads폴더 내부에 해당 경로에 해당하는 폴더에 저장한다.
근데 장고가 이 폴더에 엑세스 권한이 없다.
Media_url : media/ 경로는 media_root와 같다. 따라서
경로들/uploads/avatar 은
/media/avatar과 같은 경로이다.
이때 앞에 /을 붙여주면 그것은 절대경로를 의미함다. /media/
상대경로일때는, 내url 뒤에 /media를 추가하는 것이 되어버린다.

django settings는 .으로 하는게 아니라 , django-conf에서 import 해야한다.
(파일명이 바뀌어도 설정상 settings인것을 import한다?)

파일을 서버에 저장하지 않아도 되는 것은 마지막쯤에 배운다.amazon s3와 같은 별도 서버에 저장하는 방법인 듯

django.conf.urls.static import static
Static_url 생성?
Debug=true : 에러가 생기면 웹사이트에서 그대로 보여줌
If settings.DEBUG:
urlpatterns+=static(setting.MEDIA_URL, document_root=settings.MEDIA_ROOT)

위에 사진에서 파일을 제공할때 ,디버그 모드이면 파일을 자체 서버에서 제공하고, 프로그램을 아마존에 올리고 디버그x라면, 나중에 배우는 방법으로 아마존 서버에서 가져온다.
Database또한 나중에는 아마존 서버등에 저장


—ch11
Django는 게으르다. 즉, User.objects.all()[:10]은, 실제로 10개만 불러온다
request.GET로request들을 불러올 수 있다.
Querydict는 .get(key,default)으로 정보를 가져올 수 있다
User.objects.all()로 obj를 만들어도, 이것을 시제로 사용하지 않으면(print나 기타 등등), 여전히 불러오지는 않는다.
장고가 게으른거야, 쿼리셋이 게으른거야?

Django builtin filter ref

https://docs.djangoproject.com/ko/3.2/intro/tutorial03/

paginator
from django.corr.paginator import Pagintaor
get으로 page arg 가져오기
필요 요소 : 한 page의 길이, 전체 ele list (ele.objects.all())

요소 obj.
Dir(obj.paginator)로 확인 가능
number: 현재 page
get_page
paginator.page_count: 전체 page
paginator.page_range
object_list
등등 doc확인하자

Get_page vs page
전자는 좀 더 간편, 후자는 좀 더 에러컨트롤에 유용

orphans: page길이가 10이라면, 1~9까지가 있는 apge는 orphans
23개의 ele가 있다면, 10 + 10 + 3대신
10+ 13으로 만들어준다(oprhans가 3이상이면)


Paginator을 하면 paginator obj가 생성된다.
paginatorObj.get_page(or page)를 하면 page obj가 생성된다.
page에서 paginator의 method를 쓰려면, pageObj.paginator.method를 하면 된다.
- page는 paginator의 한 페이지 이므로, page_num 같은건 더 페이지그룹(paginator)에서 구해야한다