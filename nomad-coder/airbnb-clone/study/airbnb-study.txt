Airbnb - clone 
    무슨 css : utility-first css, 이미 구현된 디자인 이용
    Django와 Django Template를 이용한 Backend Frontend 구현 

git ignore: 동기화 하지 않을 파일 선택 
	프로젝트 최상단에 위치하여야 한다.

vscode
    https://sosomemo.tistory.com/53
    https://webnautes.tistory.com/1158
    vsc 세팅은 추후에 공부하자
    가상화를 지원하는 project (pipenv 등)는, 해당 폴더만 독립적으로 사용하자(linux에서 . code 이용)
    설정: 사용자 원격 작업영역, 작업영역은 현재 vscode 영역, 사용자와 원격은 전역설정과 유사하다고 생각됨

Airbnb - clone setting 
    sudo apt-get update && sudo apt-get upgrage : 무언가를 설치하기 전에 반드시 하자
    sudo apt upgrade python3 : 선택사항
    sudo apt install python3-pip : pip설치
    pip install --user pipenv 
        pipenv PATH 설정 - 하단참고 
    pipenv --three : bubble(가상화 생성)
    . code : pipenv를 code에서도 제대로 이용하려면, 가상화 된 폴더만 따로 취급하는것이 좋은듯하다.
        이제부터 vsc에서도 터미널을 열어서 수행할 수 있다.
    pipenv shell: bubble 진입, 새로운 터미널을 열 때마다 해주어야 한다.
    vsc python 설치 : pylance, Jupyter도 같이 설치된다.
    좌하단의 python버전을 나의 python 버전 + pipenv로 선택 
    vsc 명령팔레트(ctrl+shift+p) - select linter - flake 8
        설정하고 아무 .py클릭하면 알아서 설치한다.
            pipenv install flake8  --dev 로 설치됨
        설치후 settings.json 확인, 아래 문구가 추가된다.
            "python.linting.flake8Enabled": true,
            "python.linting.enabled": true,
        아래문구를 추가한다, pylint 충돌 방지 
            "python.linting.pylintEnabled": false, 
        linting 사용자 설정 가능
            string 최대 길이 늘리기: "python.linting.flake8Args": ["--max-line-length=120"]
    vsc 터미널 - pipenv install black --dev --pre
        black은 직접 설치한다.
        설치후 settings.json에 아래 문구를 추가한다.
            "editor.formatOnSave":true,
    	    "python.formatting.provider": "black",
        저장시 black이 작동하면 된 것이다.
            문법오류 있으면 black이 작동하지 않을 수 있으므로 조심한다.
    pipenv install Django==2.2.5
        ==2.2.5 로 버전을 명시하면 해당 버전 설치(강의가 2.2.5)
        버전을 명시하지 않으면 최신버전 설치 

pip install --user PACKAGE
    https://www.lesstif.com/python/python-pip-user-mode-95879683.html
    pip는 PACKAGE를 system경로에 설치한다.
        -> PACKAGE를 이용할 때마다 root권한을 얻거나, 
            system디렉토리를 일반 사용자에게도 허용해야한다.
    --user 모드를 이용하면 root권한 없이 사용자 디렉토리에 설치 가능하다.
        사용자 디렉토리 주소: /home/rain/.local/bin
        $ python3 -c 'import site; print(site.USER_BASE)' 을 통해 주소를 얻을 수 있다.
    사용자 디렉토리는 PATH지정이 안되어 있으므로, 해당 주소를 PATH에 등록해야한다.
        ~/.profile 편집 vs ~/.bashrc 편집    
            .profile은 Login Shell을 위한것이고, .bashrc는 Non Login Shell을 위한것이다.
            Login Shell은 ID/PW를 입력하는 상황, Non..은 GUI에서 터미널을 여는 상황이다.
            Non.. 은 Login Shell에서 상속받는다.
            따라서 .profile에 PATH를 추가하는 것이 권장된다.
        ~/.profile 편집 
            if [ -d "$HOME/.local/bin" ] ; then
                PATH="$PATH:$HOME/.local/bin"
            fi
        ~/.bashrc 편집
            export PATH="$HOME/.local/bin:$PATH"
        $HOME/.local/bin:$PATH 은 디렉토리 주소같은데, 위에서 따온걸 넣어줘도 되려나?

Frontend
    Library: React 
        주류 Frontend(React)
        다양한 상호작용을 하는 프로그램에 적합
        구조를 직접 자유롭게 만든다.
    Framework: Django Template
        콘텐츠 위주의 프로그램에 적합 
        layout이 강요된다 - 시간이 적게든다.

Backend
    minimal : Flask, Pyramid
        다양한 기능을 직접 만들어야 한다.
        사용자가 원하는대로 구현할 수 있다.
    not minimal : Django
        공통적으로 필요한 기능들이 대부분 구현되어있다.
        layout이 강요된다 - 시간이 적게든다.

Django
    특징
        객체지향 프로그래밍이다. class, inheritance 위주
            inheritance를 통해 기능을 확장할 수 있다. class name(inherit target)
        Backend와 Frontend 모두 지원한다. 주로 Backend에 이용
        Document에서 필요한 것들을 찾아볼 수 있다.
            https://docs.djangoproject.com/en/2.2/ 
        Django Project - Applications - functions
            Project: Airbnb
            Applications: room, reservation, user ...
                한 문장으로 설명 가능한 정도로, 작은 단위로 모듈화한다.
            functions: application의 기능들 
    명령어  
        django-admin : 실행 가능한 명령어들을 보여준다.
        python manage.py runserver: 서버 실행
            migration에 영향을 주지 않는 내용을 수정하면, 재시작 필요없이 새로고침된다.
            Error: That port is already in use : 서버 종료후 port가 제대로 반환되지 않은 것
                sudo lsof -t -i tcp:8000 | xargs kill -9 
        python manage.py createsuperuser: 관리자 생성
        python manage.py makemigrations: 데이터를 통해 migration 생성
        python manage.py migrate: migration 적용 
    웹사이트
        /admin : 관리자 화면, config/urls.py 에서 접근주소 변경 가능 
    migration?
        django 는 data models를 확인하고 migration을 생성한다?
            data models - migration - database ? 
            data model을 장고가 사용하는 데이터 유형으로 동기화 하기 위한 migration?
            python manage.py migrate
                데이터를 sql로 migrate
        데이터에 영향을 주는 것이 생기면 migration을 생성하고 migrate 한다.
        migration은 적게 유지하는 것이 좋다. 한개만 있도록 해주자 
    프로젝트 만들기
        프로젝트이름으로 폴더를 생성하고 들어간다.
        필요하면 가상화를 한다 (pipenv)
        아래에서 생성된 파일명들을 변경하는것은 안되지만, 추가로 생성하는것은 자유롭다.
        Project 생성
            django-admin startproject config : 관리파일 생성
            생성된 폴더 내부의 파일들을 밖으로 뺀다. 빈 폴더는 삭제 
            settings.py
                django의 setting 관리
                INSTALLED_APPS는 DJANGO_APPS와 PROJECT_APPS로 구분하여 관리하면 편하다.
                THIRD_PARTY_APPS은 INSTALLED_APPS에 추가하지 않는다?
                    유용한 THIRD_PARTY_APPS
                        django_countries: 많은 나라의 list
                AUTH_USER_MODEL = "users.User" : user model을 users application에서 만든 User class로 대체한다.
                    기본 기능에서 확장을 하고 싶다면, 기본 model을 상속하고 확장하여, 기본 model을 대체하면 된다.
                주석으로 Document 등 여러 쓸만한 링크들을 제공한다  
            urls.py
                url을 컨트롤 하는 것, 원칙적으로 url은 여기에서 추가한다.
                application에 urls.py를 추가하여 간접적으로 관리가 가능하다.  
        Application 생성
            django-admin startapp AppNames: application 생성, 이름은 복수형으로 짓자
                AppNames는 DJANGO_APPS와 겹치지 않도록 하자. config-setiings.py에서 확인가능 
                생성후 settings.py의 INSTALLED_APPS에 추가해야 적용된다.
            admins.py : admin에 반영되는 것들
            apps.py : cofiguration 파일
            models.py : database와 form(app)에서 이용할 데이터를 정의한다.
            views.py : 사용자에게 보여지는곳, html render
    Applications
        Django Documentation에서 원하는 기능을 찾으면 된다.
        import는 python - django - third_party - user_app 순서로하자 (상위에서 하위로)
        models.py : 데이터를 추가할 수 있다
            database label = models.입력형태()
            입력형태는 model field로 검색하면 된다.
            sql database에 data를 빈공간으로 두는 옵션  
                1. default = blabla : deafult value 설정
                2. null = True : 빈 필드 허용
            form 옵션 
                blank = True : 내용을 채우지 않아도 submit 할 수 있다.
                    https://stackoverflow.com/questions/4384098/in-django-models-py-whats-the-difference-between-default-null-and-blank
            model field 
                image: Pillow 설치 필요 -> bubble화되어있다면 pipenv 사용하자
                char: max_length 필수, 선택지 제한 기능(choices = choice_tuple)
                    choice_tuple = ( (database name 1, form name 1), (2,2), ...)
                text : 일반적인 text field 
                Date : 날짜, sql기본값이 없기때문에 null=True가 불가능하다.
                DateTime : 더 세부적인 날짜
                    두 Date 모두 객체 업데이트시간(auto_now), 생성시간(auto_now_add)를 이용할 수 있다.
        admin.py: admin 설정 관리
            admin.py에서 사용자가 만든 model을 이용하려면,admin class에 register 해야한다.
                여러개의 model을 한 admin에 동시에 register 할 수 있다.
            아래 내용은 사용자가 만든 User model을, 사용자가 만든 CustomUserAdmin에 register한 것이다.
                이때 CustomUserAdmin은 UserAdmin을 상속하여 확장시킨 것이다.  
                    @admin.register(models.User, models.anotherClass1)
                    class CustomUserAdmin(UserAdmin)
                        blablabla
            상속 선택지
                admin.ModelAdmin : 기본값이 없는 상속?
                UserAdmin : Django가 제공하는 기본 admin    
                    from django.contrib.auth.admin import UserAdmin
                    UserAdmin.fleldsets : 기본 admin의 default fieldsets
                    fieldsets = UserAdmin.fieldsets + CustomAdmin 과 같이 혼용 가능 
            요소
                list display: 정렬 항목에서 보일 것 선택
                list filter: 항목 필터에 사용할 것 선택 
                fieldsets: 정보를 그룹지어 나타낸다
                    ( (field 1 name, {"classes":("bla",), "fields":(model1,model2)}), (field 2 name ~) ... )
                    classes: 해당 fieldset의 특성을 바꾼다.
                        collapse: fieldset을 열고 닫게 해준다.
                ordering : 정렬의 기준이 되는 element 선정(나이, 성별 순 등)
                search_field: 대상 search
                    검색옵션: startswith(^), iexact(=), search(@), icontains(None)
                filter_horizontal: ManyToMany에서 작동, 좌측은 미선택, 우측은 선택 박스
                function : row에 ele 대신 function을 넣을 수 있다.
                    ManyToMany등의 요소는 row에 넣을 수 없기때문에, func를 이용하면 유용하다.
                        def name(self, obj): return "strings"
                        self = this admin, obj = model that use this admin 
                ele.short_description: admin panel에서의 항목설명을 바꿀 수 있다.
        User Application
            AbstarctUser을 상속하여 사용하는것이 일반적이다?
            User application의 존재의의
                Django의 admin에서는 user정보를 관리할 수 있지만, 이는 관리자를 위한것이다.
                사용자가 스스로 user정보를 관리할 수 있도록 user application을 만든다.
        Core Application
            여러 application에서 공통적으로 사용하는 요소들을 정의해둔다.
            User를 제외한 모든 app의 기능은 core에서 확장시켜 나간다.
                abstractUser가 이미 쓸만한 기능들이 많아서 그런듯?
            class Meta: abstract 를 이용하여, 자체 database를 사용하지 않도록 하자
                즉, 이를 상속한 class의 database에만 정보를 저장하자
            사용례
                time stamp: created(auto_now_add), updated(auto_now)
    CustomCommand 만들기
        python manage.py CustomCommand
        구조생성
            application - management폴더 생성 : 원하는 app에 management 폴더 생성
            management폴더 내부에 __init__.py, commands폴더 생성 
            commands폴더 내부에 __init__.py, customCommandName.py 생성
            customCommandName.py 구조
                명령어의 이름은 파일명에서 정의했으므로, 나머지 구조는 django layout을 따른다.
                from django.core.management.base import BaseCommand: BaseCommand 상속
                    Command는 BaseCommand 혹은 그것의 subclass(Doc참고)를 상속해야한다.
                from polls.models import modelClass: 명령어의 수행과 관련된 class import
                class Command: command 구현 
            class Command 구조    
                help = "explain"
                def add_arguments(self,parser):   //명령어의 option 추가 
                    parser.add_argument("--times", other args)
                        default : --times timesNum 에서 timesNum이 없을경우 default
                        type = int : 입력 설정
                        help : 설명 
                    // arguments들은 handle의 options에 arr형태로 들어간다.
                    // 따라서 options["times] 혹은 options.get("times")로 times를 얻을 수 있다.
                def handle(self,*args,**options): //command의 logic, 구현 필수
                    //self = obj,  
                    // add_argument로 추가된 arg는 options에 arr형태로 가져온다.
                    logic
        명령어들
            ModelName.objects.create(name = a, ele1 = bla): obj 생성
                ModelName 의 object를 생성한다.
                required ele들은 모두 넣어주어야 한다.
                Amenities와 같이 정해져 있는 것들을 한번에 만들때 유용하다.
            self.stdout.write(self.style.SUCCESS("strings")): 표준 출력
                SUCCESS(초록), WARNING(주황), ERROR(빨강) str 출력 
        THIRD_PARTY_APPS
            django-seed: fake-data 생성기, install django-seed 필요 
                구조
                    from django_seed import Seed: Seed import
                    seeder=Seed.seeder(): seed함수     
                    seeder.add_entity(User,num,{options}): User obj를 option에따라 num개 생성
                    seeder.execute(): 생성한것을 적용, 생성한것들의 pk arr 반환
                        이 pk를 이용하여, 일단 생성한 후 elements를 수정해도 된다.
                        flatten을 이용하면 편하다?
                options
                    {ele1:bla, ele2:blabla, option3, ...} 와 같은 형식 
                    option으로 정해지지 않은것은 랜덤으로 설정된다.
                    완전랜덤이 아닌 logic을 원한다면, lambda x: 를 이용하면 된다,
                    ForeignKey, ManyToMany와 같이 다른 model의 class를 지정하는것은 랜덤생성이 불가하다.
                        직접 logic을 설계해야한다.
                        all_users = user_models.User.objects.all() 와 같은 방식으로 target model class를 가져와야한다.
                            위 방법은 object가 많을 경우 비효율적이므로 권장되지 않는다. 참고만 하자 
                faker 명령어
                    https://faker.readthedocs.io/en/master/
                    from faker import Faker     
                        Faker().text(), and etc ...
                    lambda x: seeder.faker.text()로 사용 해야 진정한 랜덤 
        기타 요소
            import random
                fake data logic을 설계에 유용하게 사용할 수 있다.
            from django.contrib.admin.utils import flatten
                정확히 무슨 기능과 용도인지 추가바람 
                seeder.execute()가 iterator을 반환하는가?
                    https://www.programiz.com/python-programming/methods/built-in/filter
                ret={<class "movies.models.Movie">: [1,2,3,4,5, .. ,num]} 의 형식으로 반환되고
                ret.values() = ([[1,2,3,4,5, .. ,num]]) 과 같이 반환된다.
                flatten(ret.values()) = [1,2,3,4,5, .. ,num]
            from datetime import datetime, timedelta
                timedelta(days=random.randint(3, 25)): 시간을 추가하는 용도로 쓰인다.
    기타요소
        class Meta: 추가적인 기능, 정보등을 다루는 class
            abstract: 자체 database를 사용하지 않는 model임을 나타낸다.
                즉 대부분, 상속을 위한 class가 이 속성을 가진다.
                abstractUser도 abstract의 성질을 가진다.
            verbose_name: admin panel에서 표기되는 이름
            verbose_name_plural: admin panel에서 표기되는 복수형 이름 
        relationship
            다른 app의 model에서 생성된 obj와 연결한다.
            obj의 변수 또한 접근이 가능하다. self의 변수와 동일하게 이용 가능한듯?
                str 방식: "host__superhost"
            종류
                ForeignKey(many to one)
                ManyToMany
                OneToOne
            args 
                blank = True : all
                    주로 ManyToMany에서 많이 이용한다.
                on_delete: ForeignKey, OneToOne?
                    연결 대상(상위객체)이 삭제될 때의 self(하위객체)의 동작
                        CASCADE: 상위객체가 삭제되면 하위객체도 삭제
                        PROTECT: 상위객체를 삭제하려면 하위객체가 없어야함
                        etc... on document    
                related_name: all
                    상위객체에서 하위객체들을 찾을 때, set의 형태로 찾을 수 있다.
                    이 set의 이름을 바꾸어 주는 역할을 한다.
                    set_eleName에서 set_related_name으로 바뀐다. 
                limit_choices_to  
                    선택할 수 있는 상위객체를 제한
                    조건: AND OR
                        AND: limit_choices_to={'share_holder': True, 'distributor': True}
                        OR : Q(share_holder=True) | Q(distributor=True)
                    What is Q 
                        bool 조건에 더 다양한 선택지를 주는 것 같다.
                        https://stackoverflow.com/questions/30181079/django-limit-choices-to-for-multiple-fields-with-or-condition
                        https://docs.djangoproject.com/en/dev/topics/db/queries/#complex-lookups-with-q
        get model from string 
            Django의 특징 
            class가 현재 class보다 아래에서 정의되었거나, 다른 model에 존재하는 경우 유용하다.
            model class를 modelName.className 대신, "modelName.className"으로 불러오는 방법
                다른 model에서 import하는 것이 아니면, modelName은 제외한다
                import model1 as model1111 일 경우, "model1111.className"도 되는지 확인요망
            https://stackoverflow.com/questions/4881607/django-get-model-from-string
            https://docs.djangoproject.com/en/2.2/ref/applications/#initialization-process
            https://docs.djangoproject.com/en/3.2/ref/applications/#django.apps.AppConfig.get_model


Python  
    from . import func : .은 현재 폴더를 의미한다.
        즉, 같은 폴더내의 있는 파일들의 func를 import 한다는 뜻의 코드
    class definition: 정의 바로 아래 """class definition"""을 추가한다.
        class name에 커서를 올리면 class definition이 보인다.
    파이썬 패키지관리자: pipenv, venv
        파이썬에는 nodeJs의 npm과 같은 패키지관리자가 없다.
        pip는 전역으로만 설치하므로, 프로젝트 도구(django등)을 격리하여 다룰 수 없다.
        pipenv, venv는 가상화를 통해 프로젝트 도구를 격리시킨다.
        pipenv: 파이썬을 위한 npm + package.json 
            pipenv --three: python3를 이용하는 bubble(가상화) 생성
            pipenv shell : bubble 진입
            pipenv install PACKAGE : PACKAGE를 bubble에 설치 
    Linter : flake8, etc...
        python은 compiled언어가 아니어서, 에러를 컴파일전에 파악할 수 없다.
        linter는 예상되는 에러를 찾아내준다.
        python PEP라는 python작성약속에 따라, 보기 좋지 않은 코드도 알려준다.
    Formatter : black
        python PEP에 따라 코드를 보기좋게 수정해준다.
        단순히 보기좋게 수정해주는 것이고, 코드는 건들지 않는다. 
    __init__.py : 좀 애매한데 추후 다시 공부하자 
        폴더에 이것을 넣어두면, 파이썬이 이 폴더를 import한 것과 같은 역할이다.
        따라서 폴더랑 같은 위치에 있는 다른 파일에서, 폴더내의 파일을 사용할 수 있다.
        ex) : manage.py의 os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
    __str__ : 추후 공부 더 필요
        파이썬과 장고의 모든 class가 가지고 있는 method
        obj를 발견했을때, 그것을 표현하는 방법이다.
            기본적으로는 __str__은 obj의 이름을 반환한다.
            __str__을 수정함으로서, 다양한 str을 반환할 수 있다.
            obj.ele, "strings", f"{obj.ele} is ele" 등등, str형식이면 다 된다.
    상속
        여러개를 상속할 수 있다? django만 가능? 


decorator
    class 바로 위에 적어서, decrator의 내용을 아래 class에 적용한다.
        @admin.register(models.User)
        class CustomUser(UserAdmin):
            blabla
    decorator를 쓰지 않는다면, 아래와 같이 하면된다
        class CustomUser(inherit):
            blabla
        ... other codes ... (중간이 비어도 된다는 뜻)
        admin.site.register(models.User, CustomUser)

SQL Database    
    여러 종류가 있다. 
        dq.splite3 
    첫 행은 변수이름 = 변수형식 으로 지정한다. 다음행부터는 데이터 입력


장고는 database랑 통신
장고 ORM (object relational mapping): 파이썬 코드를 sql문으로 바꿔서 데이터베이스가 알아먹도록 
	model에 넣는것을 database로 변경
    Django가 sql언어로 알아서 바꾸어준다.

Chrome localhost 접속불가 
    https://solbel.tistory.com/586
    크롬은 http localhost를 강제로 https localhost로 바꾼다.
    https설정이 안되어 있다면 접속할 수 없다. 

정보 관리
    사용자가 직접 내용을 입력
        model을 admin에 등록 - admin panel에서 수정 가능
    사용자는 정해진 항목을 선택
        등록 x - 코딩을 통해서만 항목을 수정 가능 
        ex: 국가목록의 경우에는 직접 추가하기보다는, 이미 있는 것들만 사용하게 하도록

 